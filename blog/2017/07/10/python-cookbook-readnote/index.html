<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Python Cookbook 读书笔记 - org-page</title>
    <meta charset="utf-8" />
    <meta name="author" content="Astropeak" />
    <meta name="description" content="Python coookbook reading notes" />
    <meta name="keywords" content="python, cookbook, reading notes" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">org-page</a></h1>
        <p>static site generator</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/kelvinh/org-page">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="astropeak.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Python Cookbook 读书笔记</h1>
<p>
《<a href="http://shop.oreilly.com/product/0636920027072.do">Python Cookbook</a>》读书笔记.
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">chapter 1: Data Structures and Algorithms</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">1.6 Mapping Keys to Multiple Values in a Dictionary, by list value and defaultdict</h3>
<div class="outline-text-3" id="text-1-1">
<p>
example: create a dictionary with default value, by defaultdict
</p>

<p>
dictionary's property:
</p>
<ol class="org-ol">
<li>you can add new key to a dictionary
</li>
<li>but when you access a key that not exists, there will be error
</li>
<li>defaultdict is used to fix such problem.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-python">from collections import defaultdict
`dict` = defaultdict(`func list`)
# `dict`['aaa'].append(2)
$0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">1.6 example</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-python">from collections import defaultdict
frequency = defaultdict(int)
frequency['colorless'] = 4
frequency['ideas'] # will be 0

frequency = defaultdict(list)
# first, frequency['colorless'] will return a empty list, then append one element to this list.
frequency['colorless'].append(4)
frequency['ideas'] # will be []

# Or you can pass a function take no arguments 

# the idiom:
my_dictionary = defaultdict(function to create default value)
for item in sequence:
my_dictionary[item_key] is updated with information about item
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">1.7 Keeping Dictionaries in Order, OrderedDict</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-python">form collections import OrderedDict
d = OrderedDict()
# the insertion order will be reserved.
</pre>
</div>

<p>
An typical application is when for serilization.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">1.8. Calculating with Dictionaries</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">get max key/value in a dictionary, based on the value, by inverting the dict</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">

<pre class="src src-python">max(zip(`dict`.values(), `dict`.keys()))
# another solution
# max(`dict`, key=lambda k:`dict`[k])
</pre>
</div>
<p>
first convert the dict to list of (value, key) pairs, then max function will first compare value, then compare key.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">result of the max value for many  things</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
for tuple and list, it just the element.
but for a dict, it returns only the key. Why? Because it accept a iterable as first parameter, and for a dictionary, the iterable value is the key.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">understanding of multi value bind</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
---&gt;  (b11, b12) = 1
TypeError: 'int' object is not iterable
</p>

<p>
The right hand side should be an iterable, every element in the iterable will be asigned to the left hand side variable, with each variable comsume one element exzactly. If the number of elements and variables not match, then there will be an error.
</p>

<p>
To consume more than one values, use the '*varname' expresstion, then the variable 'varname' will be a list of many elements.
</p>

<p>
Back to the error prints in the example, the 'int' object refers to the right side '1'.
</p>

<p>
PS:
I find python much simpler and funny than java.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">1.9. Finding Commonalities in Two Dictionaries</h3>
<div class="outline-text-3" id="text-1-5">
<p>
a dictionary's d.keys() and d.items() support set operations
So to find the common part keys/items in two dictionaries, just use the set operation '|' or 'union' function.
</p>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">get all keys as a iterable in a dictionary, by keys()</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">

<pre class="src src-python">`dict`.keys()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">get all values as a iterable in a dictionary, by values()</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">

<pre class="src src-python">`dict`.values()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">get all key, value pairs as a iterable in a dictionary, by items()</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">

<pre class="src src-python">`dict`.items()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">set operations</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
'|': union
'&amp;': intersection
'-': difference
's1 &lt; s2': check if s1 is a subset of s2
</p>

<p>
Example:
In <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>: e.keys(), d.keys()
Out<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup>: (dict_keys([1, 4, 'a', 9]), dict_keys([1, 3, 5]))
</p>

<p>
In <sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>: e.keys() &amp; d.keys()
Out<sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup>: {1}
</p>

<p>
In <sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>: e.keys() | d.keys()
Out<sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup>: {1, 3, 4, 5, 'a', 9}
</p>

<p>
In <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>: e.keys() - d.keys()
Out<sup><a id="fnr.4.100" name="fnr.4.100" class="footref" href="#fn.4">4</a></sup>: {9, 4, 'a'}
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">1.10. Removing Duplicates from a Sequence while Maintaining Order</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">problem: what is hashable(and the link to python glossary)</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
From the python glossary: 
<a href="https://docs.python.org/3/glossary.html">https://docs.python.org/3/glossary.html</a>
</p>

<p>
An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() or __cmp__() method). Hashable objects which compare equal must have the same hash value.
</p>

<p>
Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.
</p>

<p>
All of Python’s immutable built-in objects are hashable, while no mutable containers (such as lists or dictionaries) are. Objects which are instances of user-defined classes are hashable by default; they all compare unequal, and their hash value is their id().
</p>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">how yield/generator iterator is implemented</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
From the glossary, it works by suspends the function and  return the value, and save the current status. Then if it was called  next time, it will start execute from the place last time it was suspended. Great!! I understanded this.
</p>

<p>
generator
A function which returns a generator iterator. It looks like a normal function except that it contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the next() function.
Usually refers to a generator function, but may refer to a generator iterator in some contexts. In cases where the intended meaning isn’t clear, using the full terms avoids ambiguity.
</p>

<p>
generator iterator
An object created by a generator function.
Each yield temporarily suspends processing, remembering the location execution state (including local variables and pending try-statements). When the generator iterator resumes, it picks-up where it left-off (in contrast to functions which start fresh on every invocation).
</p>
</div>
</div>

<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">file object is also an iterable, the element is a line</h4>
<div class="outline-text-4" id="text-1-6-3">
<div class="org-src-container">

<pre class="src src-python">with open(somefile,'r') as f:
    for line in f:
        print(line)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4">a function that delete all duplicates in a list, with order preserved</h4>
<div class="outline-text-4" id="text-1-6-4">
<div class="org-src-container">

<pre class="src src-python">def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)
</pre>
</div>
<p>
If the element is hashable, then key function is not needed. Else, provide a fucntion to convert the  element to a hashable element.
</p>

<p>
examples:
&gt;&gt;&gt; a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
&gt;&gt;&gt; list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
&gt;&gt;&gt; list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
&gt;&gt;&gt;
</p>
</div>
</div>

<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5">delete all duplicates in a list, don't preserve order, by set</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">

<pre class="src src-python">set(`list`)
</pre>
</div>
<p>
Then all duplicate elements in list will be removed.
</p>
</div>
</div>

<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6">the a?b:c expression in python, if else in one line</h4>
<div class="outline-text-4" id="text-1-6-6">
<div class="org-src-container">

<pre class="src src-python">val = b if a else c
</pre>
</div>
<p>
looks good
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">1.11. Naming a Slice</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">the slice object</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
create a  slice
</p>
<div class="org-src-container">

<pre class="src src-python">a=[1,2,3,4]
s = slice(1,2)
print(a[s])
print(a[1:2])
</pre>
</div>
<p>
'1:2' is just a shortcut to 'slice(1,2)'
</p>

<p>
slice attributes
</p>
<div class="org-src-container">

<pre class="src src-python">s = slice(1,2,2)
print(s.start, s.stop, s.step)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">1.12. Determining the Most Frequently Occurring Items in a Sequence</h3>
<div class="outline-text-3" id="text-1-8">
<p>
A method by me
</p>
<div class="org-src-container">

<pre class="src src-python">a = [1, 2, 1, 3, 2,3,3]
from collections import defaultdict
d = defaultdict(int)
# b = [d[k]+=1 for k in a]  # syntax error here
for k in a:
    d[k]+=1

r = max(zip(d.values(), d.keys()))
print(r[1])
</pre>
</div>
</div>


<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">the collections.Counter class: change a list to a list of tuple of (element, count)</h4>
<div class="outline-text-4" id="text-1-8-1">
<div class="org-src-container">

<pre class="src src-python">a = [1, 2, 1, 3, 2,3,3]
from collections import Counter
b = Counter(a)
c = b.most_common(1)
print(c[0][0])

# get the count
print(b[3]) # 3 is the element in a


# update with more words
b.update([4, 2, 5])

# and a Counter object support the math operations: '+' and '-'
</pre>
</div>

<p>
When you need to count data, use Counter class. This is a so little class, in practice, I will always write it from scratch before.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">1.13. Sorting a List of Dictionaries by a Common Key</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">the operator.itemgetter function</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
it will return a callable that can be passed to 'sorted':s key  parameter, for list  or dictionary
</p>
<div class="org-src-container">

<pre class="src src-python"># return value of
import operator
operator.itemgetter("name")
# is the same as this one
lambda r:r["name"]
# but the former  is a little faster
</pre>
</div>

<p>
仍然是非常小的功能，为什么搞得这么精细呢？
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">1.14. Sorting Objects Without Native Comparison Support</h3>
<div class="outline-text-3" id="text-1-10">
</div><div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1">the operator.attrgetter function</h4>
<div class="outline-text-4" id="text-1-10-1">
<p>
it will return a callable that can be passed to 'sorted':s key  parameter, for user defined class
</p>
<div class="org-src-container">

<pre class="src src-python">class User():
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'User({})'.format(self.name)

# return value of
operator.attrgetter("name")
# is the same as this one
lambda o:o.name
# but the former  is a little faster
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">1.15. Grouping Records(a sequence of dictionaries) Together Based on a Field</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1">the itertools.groupby function: group sequencially the list as tuple (key, items)</h4>
<div class="outline-text-4" id="text-1-11-1">
<div class="org-src-container">

<pre class="src src-python">import itertools
rows =  [{1:2}, {1: 4},  {1: 3}]
# a should be a generator
rows.sort(key=itemgetter(1))
a = itertools.groupby(rows, key=itemgetter(1))
</pre>
</div>

<p>
another way is just use a default list dictionary to group, then no sort is needed.
</p>
</div>
</div>
</div>






<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">1.16. Filtering Sequence Elements</h3>
<div class="outline-text-3" id="text-1-12">
<p>
To fitering, just use list comprehension with an if condition
</p>
</div>
<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1">itertools.compress function, a filtering tool</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
it takse two parameters:
</p>
<ol class="org-ol">
<li>an iterable which to be compressed
</li>
<li>a Boolean sequence, with the same length of first parameter
if the element in this sequence  is True, then the element at the same position in the first iterable will be put to the output

<p>
An example:
</p>
</li>
</ol>
<div class="org-src-container">

<pre class="src src-python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK'
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]

import itertools
b = [e &gt; 5 for e in counts]
a = itertools.compress(addresses, b)
# Now a will be all items where count larger than 5
print(a)
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">1.17. Extracting a Subset of a Dictionary</h3>
<div class="outline-text-3" id="text-1-13">
</div><div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1">dictionary comprehension, just like list comprehension, but use '{' instead of '['</h4>
<div class="outline-text-4" id="text-1-13-1">
<div class="org-src-container">

<pre class="src src-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
# Make a dictionary of all prices over 200
p1 = { key:value for key, value in prices.items() if value &gt; 200 }
# Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:value for key,value in prices.items() if key in tech_names }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">1.18. Mapping Names to Sequence Elements</h3>
<div class="outline-text-3" id="text-1-14">
</div><div id="outline-container-sec-1-14-1" class="outline-4">
<h4 id="sec-1-14-1">the collections.nametuple function, map an index to a name, and access to an element with that name</h4>
<div class="outline-text-4" id="text-1-14-1">
<p>
example:
</p>
<div class="org-src-container">

<pre class="src src-python">from collections import namedtuple
People =  namedtuple('People', ['name', 'age'])
p = People(name='Jim', age=12)
print(p, p.name, p.age)
</pre>
</div>

<p>
A good application:
for database selection.
</p>

<p>
The ._replace method:
Because a tuple is immutable, so to change an element, you can use _replace to  replace a field and a new one will be returned.
A tipical usage is first  create a prototype element with all field value be the default one, then update some fields with the _replace function.
Why there is a '_' in the function name?
</p>
<div class="org-src-container">

<pre class="src src-python">from collections import namedtuple
Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)
# Function to convert a dictionary to a Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)

a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
dict_to_stock(a)
# Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">1.19. Transforming and Reducing Data at the Same Time</h3>
<div class="outline-text-3" id="text-1-15">
<p>
use generator-expression argument
</p>

<p>
The reducing function means: given a list, return a value.
</p>
</div>
</div>
<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16">the any function, check if any of an element is True in a iterable</h3>
<div class="outline-text-3" id="text-1-16">
</div><div id="outline-container-sec-1-16-1" class="outline-4">
<h4 id="sec-1-16-1">check if  any .py files exist in a directory</h4>
<div class="outline-text-4" id="text-1-16-1">
<div class="org-src-container">

<pre class="src src-python"># Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
    print('There be python!')
else:
    print('Sorry, no python.')
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-16-2" class="outline-4">
<h4 id="sec-1-16-2">get all files in a directory as a list</h4>
<div class="outline-text-4" id="text-1-16-2">
<div class="org-src-container">

<pre class="src src-python">import os
files = os.listdir('dirname')
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-16-3" class="outline-4">
<h4 id="sec-1-16-3">change a tuple/list/iterable to a csv line</h4>
<div class="outline-text-4" id="text-1-16-3">
<p>
This is much better than the string format method
</p>
<div class="org-src-container">

<pre class="src src-python"># Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))# Output a tuple as CSV
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17">1.20. Combining Multiple Mappings into a Single Mapping</h3>
<div class="outline-text-3" id="text-1-17">
</div><div id="outline-container-sec-1-17-1" class="outline-4">
<h4 id="sec-1-17-1">the collections.ChainMap</h4>
<div class="outline-text-4" id="text-1-17-1">
<p>
combining many maps/dictionaries, then when get an element, it will try to get from the first map, then the second, ...
</p>

<p>
And for operations that mutate the mapping always affect the first map/dictionary.
</p>

<p>
typical application:
scoped variable in a programming language.
</p>

<p>
Difference from the dict.update function:
ChainMap use a link to the original dictionary, while dict.update create a new one.
</p>
</div>
<ul class="org-ul"><li><a id="sec-1-17-1-1" name="sec-1-17-1-1"></a>check if an element exists in many dictionaries/maps, sequencially<br  /><div class="outline-text-5" id="text-1-17-1-1">
<div class="org-src-container">

<pre class="src src-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
from collections import ChainMap
c = ChainMap(a,b)
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)
</pre>
</div>
<ul class="org-ul">
<li>chapter 2: Strings and Text
</li>
</ul>
</div>
</li></ul>
</div>
</div>
<div id="outline-container-sec-1-18" class="outline-3">
<h3 id="sec-1-18">2.1. Splitting Strings on Any of Multiple Delimiters</h3>
<div class="outline-text-3" id="text-1-18">
<p>
By us re.split and the regexp is r'[,;\s]\s*'
</p>
</div>
<div id="outline-container-sec-1-18-1" class="outline-4">
<h4 id="sec-1-18-1">difference between str.split and re.split</h4>
<div class="outline-text-4" id="text-1-18-1">
<p>
str.split only accept simple seperator
re.split accept regulare expression.
</p>
</div>
</div>
<div id="outline-container-sec-1-18-2" class="outline-4">
<h4 id="sec-1-18-2">return value of re.split</h4>
<div class="outline-text-4" id="text-1-18-2">
<ol class="org-ol">
<li>if there are no capture group, then the same as str.split
</li>
<li>if there are capture group, then all matched data will also be returned.
then the value will be rst[::2], the seperator will be rst[1::2]
<div class="org-src-container">

<pre class="src src-python">s = "I, you; a  seperater.   haha"
import re
a = re.split(r'[,;.\s]\s*', s)
print(a)

a = re.split(r'([,;.\s]\s*)',s)
print(a, a[::2], a[1::2])
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-18-3" class="outline-4">
<h4 id="sec-1-18-3">iterate on two lists, by first zip the two to one</h4>
<div class="outline-text-4" id="text-1-18-3">
<p>
looks nice!
</p>
<div class="org-src-container">

<pre class="src src-python"># Reform the line using the same delimiters
''.join(v+d for v,d in zip(values, delimiters))
'asdf fjdk;afed,fjek,asdf,foo'
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-18-4" class="outline-4">
<h4 id="sec-1-18-4">regexp noncapture group, by r'(?:...)'</h4>
</div>
</div>

<div id="outline-container-sec-1-19" class="outline-3">
<h3 id="sec-1-19">2.2. Matching Text at the Start or End of a String, by str.startswith() or str.endswith() method</h3>
<div class="outline-text-3" id="text-1-19">
<div class="org-src-container">

<pre class="src src-python">filename = "aaaa.txt"
filename.endswith(".txt")
# pass a tuple to check against multiple choices
filename.endswith((".c", ".h"))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">from urllib.request import urlopen
def read_data(name):
    if name.startswith(('http:', 'https:', 'ftp:')):
        return urlopen(name).read()
    else:
        with open(name) as f:
            return f.read()
</pre>
</div>

<p>
The parameter is simple string.
</p>

<p>
Compared to re.match, str.startswith looks nice.
</p>
</div>
</div>

<div id="outline-container-sec-1-20" class="outline-3">
<h3 id="sec-1-20">2.3. Matching Strings Using Shell Wildcard Patterns, with fnmatch.fnmatch(), fnmatch.fnmatchcase()</h3>
<div class="outline-text-3" id="text-1-20">
<p>
Shell wildcard:
</p>
<ul class="org-ul">
<li>[] : a charset
</li>
<li>* : match any length of chars
</li>
<li>? : match only one char
</li>
</ul>

<div class="org-src-container">

<pre class="src src-python">from fnmatch import fnmatch
print(fnmatch("data 1.txt", "*[0-9]*"))
</pre>
</div>

<ol class="org-ol">
<li>the pattern must match the whole string
</li>
<li>compares to startswith(), fnmatch can match at any position
</li>
<li>compares to regexp, fnmatch looks nice
</li>
<li>fnmatch will use the same case-sensitive rule as the OS, fnmatchcase will always respect case.
</li>
<li>between simpe string and full power of regexp
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-1-21" class="outline-3">
<h3 id="sec-1-21">2.4. Matching and Searching for Text Patterns</h3>
<div class="outline-text-3" id="text-1-21">
<p>
What's  the difference between matching and searching
</p>
</div>

<div id="outline-container-sec-1-21-1" class="outline-4">
<h4 id="sec-1-21-1">the str.find() function: find the start index of a substring</h4>
<div class="outline-text-4" id="text-1-21-1">
<div class="org-src-container">

<pre class="src src-python">s = "Hello xxx bbbb"
print(s.find("xx"))
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-21-2" class="outline-4">
<h4 id="sec-1-21-2">re.compile() function: compile a regexp strinng to a regexp object, for performance</h4>
<div class="outline-text-4" id="text-1-21-2">
<p>
If you use the regexp many times, then first compile it is good. But if you only use it for one time, then don't use the compile function
</p>
</div>
</div>

<div id="outline-container-sec-1-21-3" class="outline-4">
<h4 id="sec-1-21-3">difference between r'\d' and '\d'</h4>
<div class="outline-text-4" id="text-1-21-3">
<p>
if the string is prefixed by  a 'r', then the '\' in the string will not be intepreted by the string parser.
So the second regexp is actually r'd'.
</p>
</div>
</div>

<div id="outline-container-sec-1-21-4" class="outline-4">
<h4 id="sec-1-21-4">re.findall() function, find all matched data as a list</h4>
<div class="outline-text-4" id="text-1-21-4">
<div class="org-src-container">

<pre class="src src-python">text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
import re
rg = r'\d+/(?:\d+)/(?:\d+)'
a = re.match('Today', text)
print(a.group(0))
a = re.findall(rg, text)
print(a)
print(type(a[0]))
</pre>
</div>

<p>
The return value: if there are capture groups, then the return value is the captured data, and if the capture group number is one, it will be  a string, else be  a tuple of strings.
if  no capture groups, then the return value is all matched  data.
</p>
</div>
</div>

<div id="outline-container-sec-1-21-5" class="outline-4">
<h4 id="sec-1-21-5">re.finditer(), find all matched data as a iterater</h4>
<div class="outline-text-4" id="text-1-21-5">
<p>
Seems the return value is different from re.findall(), it will return a  matched object , the same as re.match()
Seems strange, and highly inconsistent.
</p>
</div>
</div>

<div id="outline-container-sec-1-21-6" class="outline-4">
<h4 id="sec-1-21-6">re.match() function, always match at the start of a string</h4>
</div>
<div id="outline-container-sec-1-21-7" class="outline-4">
<h4 id="sec-1-21-7">re.match() function, return value</h4>
<div class="outline-text-4" id="text-1-21-7">
<p>
rst.group(0): the matched data
rst.group(1): the first captured data
rst.groups(): all captured data as a tuple
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-22" class="outline-3">
<h3 id="sec-1-22">2.5. Searching and Replacing Text</h3>
<div class="outline-text-3" id="text-1-22">
</div><div id="outline-container-sec-1-22-1" class="outline-4">
<h4 id="sec-1-22-1">the str.replace function, replace all occurence in a string</h4>
<div class="outline-text-4" id="text-1-22-1">
<p>
str.replcae(pattern, replacement)
</p>
<div class="org-src-container">

<pre class="src src-python">text = 'yeah, but no, but yeah, but no, but yeah'
print(text.replace('yeah', 'yep'))
# 'yep, but no, but yep, but no, but yep'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-22-2" class="outline-4">
<h4 id="sec-1-22-2">the re.sub(pattern, replacement, text) function, will also replace all occurence in a string</h4>
<div class="outline-text-4" id="text-1-22-2">
<p>
use r'\1' to refer to the first captured group
</p>
<div class="org-src-container">

<pre class="src src-python">text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
import re
print(re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text))
# 'Today is 2012-11-27. PyCon starts 2013-3-13.'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-22-3" class="outline-4">
<h4 id="sec-1-22-3">the re.sub(pattern, callback, text) function, will also replace all occurence in a string</h4>
<div class="outline-text-4" id="text-1-22-3">
<p>
The second parameter can also be a function, the parameter to this function is a match object(the  same returned by re.match function).
</p>

<p>
The same example as the above one:
</p>
<div class="org-src-container">

<pre class="src src-python">text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
import re
def foo(m):
    (m, d, y) = m.groups()
    return '-'.join([y,m,d])

print(re.sub(r'(\d+)/(\d+)/(\d+)', foo, text))
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-22-4" class="outline-4">
<h4 id="sec-1-22-4">the re.subn(...) function, same as re.sub, but also return subsitution counts also</h4>
</div>
</div>
<div id="outline-container-sec-1-23" class="outline-3">
<h3 id="sec-1-23">2.6. Searching and Replacing Case-Insensitive Text</h3>
<div class="outline-text-3" id="text-1-23">
<p>
To do case-insensitive operations, you must use regexp with the re.IGNORECASE flags keyword parameter
</p>
</div>

<div id="outline-container-sec-1-23-1" class="outline-4">
<h4 id="sec-1-23-1">replace words in a string with original case preserved</h4>
<div class="outline-text-4" id="text-1-23-1">
<p>
a excenlent example of replacing with 原始的大小写规则. 并且是一个很好的高阶函数的例子。
</p>
<div class="org-src-container">

<pre class="src src-python">def matchcase(word):
    def replace(m):
        text = m.group()
        if text.isupper():
            return word.upper()
        elif text.islower():
            return word.lower()
        elif text[0].isupper():
            return word.capitalize()
        else:
            return word

    return replace

text = 'UPPER PYTHON, lower python, Mixed Python'
import re
print(re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE))
# 'UPPER SNAKE, lower snake, Mixed Snake'
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-24" class="outline-3">
<h3 id="sec-1-24">2.7. Specifying a Regular Expression(regexp) for the Shortest Match, by using modifier '?', no-greedy match</h3>
<div class="outline-text-3" id="text-1-24">
<p>
By default, * will match longest data. if appended with a '?' then it will match the shortest
</p>

<div class="org-src-container">

<pre class="src src-python">import re
text1 = 'Computer says "no."'
r= re.findall(r'"(.*)"', text1)
print(r)

text2 = 'Computer says "no." Phone says "yes."'
r= re.findall(r'"(.*)"', text2)
print(r)

# Now add a '?' after '*', no greedy match
r= re.findall(r'"(.*?)"', text2)
print(r)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-25" class="outline-3">
<h3 id="sec-1-25">2.8. Writing a Regular Expression for Multiline Patterns</h3>
<div class="outline-text-3" id="text-1-25">
<p>
By default, '.' will not match a new line character. 
there are two choices to let '.' match a new line character:
</p>
<ol class="org-ol">
<li>by alternative.
change r'.*' to r'(?:.|\n)*'
</li>
<li>by use the re.DOTALL flag
<div class="org-src-container">

<pre class="src src-python">s = '''/* aaaa
bbbb
cccc */'''
import re
r = re.findall(r'/\*.*\*/', s, flags=re.DOTALL)
r = re.findall(r'/\*(?:.|\n)*\*/', s, flags=re.DOTALL)
print(r)
</pre>
</div>
</li>
</ol>
</div>

<div id="outline-container-sec-1-25-1" class="outline-4">
<h4 id="sec-1-25-1">the re.DOTALL flag: let '.' match a newline character</h4>
</div>
</div>
<div id="outline-container-sec-1-26" class="outline-3">
<h3 id="sec-1-26">2.9. Normalizing Unicode Text to a Standard Representation, by unicodedata.normalize('NFC', str)</h3>
<div class="outline-text-3" id="text-1-26">
<p>
unicode may have more than one representation, see example in the book
</p>
</div>
<div id="outline-container-sec-1-26-1" class="outline-4">
<h4 id="sec-1-26-1">normalizing means make sth. has the uniform format/type</h4>
</div>
</div>
<div id="outline-container-sec-1-27" class="outline-3">
<h3 id="sec-1-27">2.11. Stripping Unwanted Characters from Strings</h3>
<div class="outline-text-3" id="text-1-27">
</div><div id="outline-container-sec-1-27-1" class="outline-4">
<h4 id="sec-1-27-1">str.strip() function. lstrip(), rstrip(), delete whitespaces characters at begining or ending</h4>
<div class="outline-text-4" id="text-1-27-1">
<div class="org-src-container">

<pre class="src src-python">s = "    a b c \n ";
print(s.strip())
print(s.lstrip())
print(s.rstrip())
</pre>
</div>
<p>
<b>*</b> delete characters in middle of string, by str.replace(), or re.sub()
</p>
<div class="org-src-container">

<pre class="src src-python">s = "   hello     word    ";
print(s.replace(" ", ""))
import re
print(re.sub("\s+", " ", s))
</pre>
</div>
<p>
<b>*</b> create a generator object  by an expression, by '(' instead of '[', like lazy evaluation on other languages
</p>
<div class="org-src-container">

<pre class="src src-python">s = '''
import os.path
rst = ""
if os.path.isfile(""):
    with open("", "r") as f:
        rst = f.read()
'''
ss = s.split("\n")

s1 = (s.strip() for s in ss)
print(s1)
for s in s1:
    print(s)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-28" class="outline-3">
<h3 id="sec-1-28">2.12. Sanitizing and Cleaning Up Text</h3>
<div class="outline-text-3" id="text-1-28">
</div><div id="outline-container-sec-1-28-1" class="outline-4">
<h4 id="sec-1-28-1">str.translate() function, change characters given a table/dictionary, the book given much unicode examples</h4>
</div>
</div>

<div id="outline-container-sec-1-29" class="outline-3">
<h3 id="sec-1-29">2.13. Aligning Text Strings</h3>
<div class="outline-text-3" id="text-1-29">
</div><div id="outline-container-sec-1-29-1" class="outline-4">
<h4 id="sec-1-29-1">the str.ljust(), str.rjust(), str.center() functions</h4>
<div class="outline-text-4" id="text-1-29-1">
<p>
accept a number, and an optionall character
</p>
<div class="org-src-container">

<pre class="src src-python">print("aaa".ljust(20, "b"))
print("aaa".rjust(20, "-"))
print("aaa".center(20, "="))
print("aaa".center(20))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-29-2" class="outline-4">
<h4 id="sec-1-29-2">the format function and the str.format methods</h4>
<div class="outline-text-4" id="text-1-29-2">
<div class="org-src-container">

<pre class="src src-python">print(format("aaa", "&gt;20")) # same as rjust
print(format("aaa", "=&lt;20")) # same as ljust
print(format("aaa", "^20")) # same as center
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python">print("{} {:=^10}".format("abc", 123))
</pre>
</div>





<p>
"%s %s" % (a, b) is old way, now should use the new way.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-1-30" class="outline-3">
<h3 id="sec-1-30">2.14. Combining and Concatenating Strings</h3>
<div class="outline-text-3" id="text-1-30">
</div><div id="outline-container-sec-1-30-1" class="outline-4">
<h4 id="sec-1-30-1">by str.join</h4>
</div>

<div id="outline-container-sec-1-30-2" class="outline-4">
<h4 id="sec-1-30-2">by + operator</h4>
</div>

<div id="outline-container-sec-1-30-3" class="outline-4">
<h4 id="sec-1-30-3">by print function's 'sep' parameter</h4>
</div>

<div id="outline-container-sec-1-30-4" class="outline-4">
<h4 id="sec-1-30-4">by format function</h4>
</div>
</div>
<div id="outline-container-sec-1-31" class="outline-3">
<h3 id="sec-1-31">2.15. Interpolating Variables in Strings, by str.format() or str.format_map() method</h3>
<div class="outline-text-3" id="text-1-31">
<p>
Note: format_map doesn't exist in python 2.7
</p>
<div class="org-src-container">

<pre class="src src-python">print("{name} is {age} years old".format(name="Tom", age=16))

name = "Jim"
age = 18
# print("{name} is {age} years old".format_map(vars()))
</pre>
</div>


<p>
format_map accept a dictionay, while format accept keywords parameters
</p>
</div>
<div id="outline-container-sec-1-31-1" class="outline-4">
<h4 id="sec-1-31-1">the vars() function, the same as locals() if no parameter</h4>
<div class="outline-text-4" id="text-1-31-1">
<p>
if pass one parameter, then it is the same as obj.__dict__
</p>
<div class="org-src-container">

<pre class="src src-python">s = 'abc'
d = 123
print(vars())
print(locals())
# print(vars(s))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-31-2" class="outline-4">
<h4 id="sec-1-31-2">the dict.__missing__(self, key) method will be called when a key not exists, then KeyError will not be raised.</h4>
<div class="outline-text-4" id="text-1-31-2">
<p>
If this method is defined, then when a key not exists, it will be called and return the value. Else a KeyError will be raised.
</p>
<div class="org-src-container">

<pre class="src src-python">class safedict(dict):
    def __missing__(self, key):
        return '{'+key+'}'

d = safedict();
print(d['name'])
d1 = dict();
# print(d1['name'])
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-31-3" class="outline-4">
<h4 id="sec-1-31-3">a function that will do variable interpolating from env, just like $var in perl, by str.format_map</h4>
<div class="outline-text-4" id="text-1-31-3">
<div class="org-src-container">

<pre class="src src-python">class safedict(dict):
    def __missing__(self, key):
        return '{'+key+'}'


import sys
def sub(text):
    return text.format_map(safedict(sys._getframe(1).f_locals))

name="Jim"
age=18
print(sub("{name} is {age} years old"))
</pre>
</div>


<div class="org-src-container">

<pre class="src src-python">people = {
   'name': ['John', 'Peter'],
   'age': [56, 64]
}

for i in range(2):
    print('My name is {{name[{0}]}}, I am {{age[{0}]}} years old.'.format(i).format_map(people))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-31-4" class="outline-4">
<h4 id="sec-1-31-4">sys._getframe([depth]): like calls in perl, get the stack frame</h4>
<div class="outline-text-4" id="text-1-31-4">
<p>
depth default to 0, means current stack frame. 
f_locals attribute is used to get all local variabls.
f_lineno attribute is the line number.
</p>
<div class="org-src-container">

<pre class="src src-python">import sys
print(sys._getframe().f_locals)
print(sys._getframe().f_globals)
print(dir(sys._getframe().f_code))
print(sys._getframe().f_code.co_filename)
print(sys._getframe().f_lineno)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-1-32" class="outline-3">
<h3 id="sec-1-32">2.16. Reformatting Text to a Fixed Number of Columns, by textwrap.fill(astr, columns, initial_indent='', subsquent_indent='')</h3>
<div class="outline-text-3" id="text-1-32">
<div class="org-src-container">

<pre class="src src-python">import textwrap
s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under."

print(s)
print(textwrap.fill(s, 60))
</pre>
</div>
</div>

<div id="outline-container-sec-1-32-1" class="outline-4">
<h4 id="sec-1-32-1">get terminal column size, by os.get_terminal_size().columns</h4>
<div class="outline-text-4" id="text-1-32-1">
<div class="org-src-container">

<pre class="src src-python">import os
print(os.get_terminal_size().columns)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-1-33" class="outline-3">
<h3 id="sec-1-33">2.17. Handling HTML and XML Entities in Text</h3>
<div class="outline-text-3" id="text-1-33">
</div><div id="outline-container-sec-1-33-1" class="outline-4">
<h4 id="sec-1-33-1">the html.escape(astr, quote=True) function:</h4>
<div class="outline-text-4" id="text-1-33-1">
<p>
escape means convert special characters to 
</p>
<div class="org-src-container">

<pre class="src src-python">s = '&lt;a&gt;this is &lt;/a&gt;'
import html
print(html.escape(s))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-33-2" class="outline-4">
<h4 id="sec-1-33-2">the str.encode('ascii', errors='xmlcharrefreplace') function: encode a string to ascii</h4>
<div class="outline-text-4" id="text-1-33-2">
<div class="org-src-container">

<pre class="src src-python">s = 'Spicy Jalapeño'
print(s.encode('ascii', errors='xmlcharrefreplace'))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">chapter 4: Iterators and Generators</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">4.1. Manually Consuming an Iterator, by next(iterator[, default]) function</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-python">with open('python-cookbook-3rd.org') as f:
    print(next(f))
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">open(filename, ...) function will return a iterator of lines in that file</h4>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">a list object is not an iterator</h4>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">use the iter(iterable) function to create an iterator given an iterable</h4>
</div>
<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4">the for x in X syntax works both for iterator and list object</h4>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">iterator and iterable</h3>
<div class="outline-text-3" id="text-2-2">
<p>
An object is said to be iterable if it has the <span class="underline"><span class="underline">iter</span></span> method defined.
The __iter__() will reutrn the iterator object.
</p>

<p>
An object is said to be a iterator if it has following method defined:
</p>
<ol class="org-ol">
<li><span class="underline"><span class="underline">iter</span></span>: which return itself
Can be tested the it.__iter__() == it is true
</li>
<li><span class="underline"><span class="underline">next</span></span>: return the next value every time it is invoked. 
</li>
</ol>


<p>
So an iterator is an iterable,  call iter(iterable) to get an iterator.
</p>


<p>
The iter(iterable) function: 
it will return 'iterable.__iter__()'
</p>


<p>
So if obja is an iterable, then iter(obja) equal obja.__iter() 
</p>
<div class="org-src-container">

<pre class="src src-python">obja = [1, 2, 3]
ia = obja.__iter__()
ib = iter(obja)
ic = iter(ib)
print(ia)
print(ib)
print(ib is ic)
print(next(ia), next(ib))
</pre>
</div>

<p>
if obja is iterator, then iter(obja) and obja is the same object.
</p>


<p>
A good ref: <a href="http://www.shutupandship.com/2012/01/understanding-python-iterables-and.html">http://www.shutupandship.com/2012/01/understanding-python-iterables-and.html</a>
</p>
</div>
<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">a example of create a iterable class</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-python">class MyList(list):
    def __iter__(self):
        return MyListIter(self)

class MyListIter(object):
    """ A sample implementation of a list iterator. NOTE: This is just a 
    demonstration of concept!!! YOU SHOULD NEVER IMPLEMENT SOMETHING LIKE THIS!
    Even if you have to (for any reason), there are many better ways to 
    implement this."""
    def __init__(self, lst):
        self.lst = lst
        self.i = -1
    def __iter__(self):
        return self
    def __next__(self):
        if self.i&lt;len(self.lst)-1:
            self.i += 1         
            return self.lst[self.i]
        else:
            raise StopIteration

if __name__ == '__main__':
    a = MyList([1, 2, 3, 4])
    ia = iter(a)
    print('type(a): %r, type(ia): %r' %(type(a), type(ia)))
    for i in a: 
        print (i)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">how does the for in loop works</h3>
<div class="outline-text-3" id="text-2-3">
<ol class="org-ol">
<li>it first get the iterable's iterator object, by calling its __iter__() method
</li>
<li>get the element by invoke the iterator's __next__() method, and bind the value to the variable.
</li>
<li>stop when an 'StopIteration' exception happens.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">the next(iterator) function</h3>
<div class="outline-text-3" id="text-2-4">
<p>
it just return iterator.__next__()
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">the iter(iterable) function</h3>
<div class="outline-text-3" id="text-2-5">
<p>
it just return iterable.__iter__()
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">the len(obj) function</h3>
<div class="outline-text-3" id="text-2-6">
<p>
it just return obj.__len__()
</p>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">4.2. Delegating Iteration</h3>
<div class="outline-text-3" id="text-2-7">
<p>
When create a class the with a underline container, just define an __iter__() method that forward the request to the underlineing container object.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">4.3. Creating New Iteration Patterns with Generators</h3>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">what is a generator?</h3>
<div class="outline-text-3" id="text-2-9">
<p>
a generator is a function that contains at lease one 'yeild' statement.
</p>

<p>
Unlike normal function, it's boyd will not be executed when it is be called, instead, it will return a generator object.
</p>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">4.4. Implementing the Iterator Protocol</h3>
<div class="outline-text-3" id="text-2-10">
<p>
use the generator instead of the <span class="underline"><span class="underline">next</span></span> method, which will be much simple.
</p>

<p>
使用yeild 创建一个Tree Node,比使用__next__函数简单多了。
</p>

<p>
yeild from syntax.
</p>
</div>
</div>
<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">4.5. Iterating in Reverse, by the reversed(obj) function</h3>
<div class="outline-text-3" id="text-2-11">
<p>
reversed only  works if the obj
</p>
<ul class="org-ul">
<li>the obj defined a __reversed__() method. or
</li>
<li>the obj's size can be determined.
</li>
</ul>


<p>
It returns an iterator.
</p>

<p>
For example, a file handler returned by the 'open()' function can't be used with the reversed function. to use it, first convert it to a list, then pass it to the reversed() function.
</p>
<div class="org-src-container">

<pre class="src src-python">with open("1.txt") as f:
    a = reversed(list(f))
    print(next(a), next(a))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">defined a customized  reversed iterator, by define the __reversed__() method</h3>
<div class="outline-text-3" id="text-2-12">
<div class="org-src-container">

<pre class="src src-python">class CountDown():
    def __init__(self, start):
        self._start = start

    def __iter__(self):
        return self

    def __next__(self):
        if self._start &gt;=0:
            n = self._start
            self._start -= 1
            return n
        else:
            raise StopIteration

    def __reversed__(self):
        return ReversedCountDown(self)

class ReversedCountDown():
    def __init__(self, orig):
        self._orig = orig
        self._n = -1
    def  __iter__(self):
        return self
    def __next__(self):
        if self._n &lt;= self._orig._start:
            self._n += 1
            return self._n
        else:
            raise StopIteration

# if __name__ == '__main__':
cd = CountDown(2)
# for a in cd:
#     print(a)

print("reversed")
for a in reversed(cd):
    print(a)
</pre>
</div>


<p>
Implemet the iterator protocal by <span class="underline"><span class="underline">next</span></span> method is a little complex compared  to by  use the yield statement. The differenc is that then the object is ... 
</p>

<div class="org-src-container">

<pre class="src src-python">class CountDown():
    def __init__(self, start):
        self._start = start

    def __iter__(self):
        n = self._start
        while n &gt;=0:
            yield n
            n -=1

    def __reversed__(self):
        n = 0
        while n &lt;=self._start:
            yield n
            n+=1

cd = CountDown(3)
for a in cd:
    print(a)

print ("reversed")
for a in reversed(cd):
    print(a)
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">4.6. Defining Generator Functions with Extra State</h3>
<div class="outline-text-3" id="text-2-13">
</div><div id="outline-container-sec-2-13-1" class="outline-4">
<h4 id="sec-2-13-1">print the surrounding previous lines if pattern matched, by use a generator, implemented by a class</h4>
<div class="outline-text-4" id="text-2-13-1">
<p>
Here previous lines are states.
</p>
<div class="org-src-container">

<pre class="src src-python">from collections import deque
class HistoryLines():
    def __init__(self, lines, histlen=3):
        self.lines = lines
        self.history = deque(maxlen=histlen)

    def __iter__(self):
        for line in self.lines:
            self.history.append(line)
            yield line

with open('1.txt') as f:
    hist_lines = HistoryLines(f)
    for line in hist_lines:
        if  'wrap' in line:
            for hl in hist_lines.history:
                print('%s' % hl)
</pre>
</div>

<p>
Good practice: if you need save some states, then don't use a function to create a generator, use a class.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">4.7. Taking a Slice of an Iterator</h3>
<div class="outline-text-3" id="text-2-14">
</div><div id="outline-container-sec-2-14-1" class="outline-4">
<h4 id="sec-2-14-1">by use of the itertools.islice(start, end, step) functon</h4>
<div class="outline-text-4" id="text-2-14-1">
<p>
Because we don't know the size of a iterator or a generator, so we can't slice it directly.
</p>
<div class="org-src-container">

<pre class="src src-python">from  itertools import islice as slice_iter
a = range(8)
for b  in slice_iter(iter(a), 2, 5, 1):
    print(b)

with open('1.txt') as f:
    for line in slice_iter(f, 2, 5, 2):
        print(line.strip())
</pre>
</div>

<p>
The result is the  same as my impllemented one.
</p>
</div>
</div>

<div id="outline-container-sec-2-14-2" class="outline-4">
<h4 id="sec-2-14-2">a try by me,  works</h4>
<div class="outline-text-4" id="text-2-14-2">
<div class="org-src-container">

<pre class="src src-python">def slice_iter(aiter, start, end, step):
    n = 0
    idx = range(end)[start:end:step]
    for i in range(end):
        v = next(aiter)
        if i in idx:
            yield v

a = range(8)
for b  in slice_iter(iter(a), 2, 5, 1):
    print(b)

with open('1.txt') as f:
    for line in slice_iter(f, 2, 5, 2):
        print(line.strip())
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">4.8. Skipping the First Part of an Iterable, by itertools.dropwhile(test_func, iterable)</h3>
<div class="outline-text-3" id="text-2-15">
<div class="org-src-container">

<pre class="src src-python">import itertools
with open('1.txt') as f:
    for line in itertools.dropwhile(lambda x: x.startswith('#'), f):
        print(line, end='')
</pre>
</div>

<p>
This is different from filtering
</p>

<p>
if the position is known, then we can use itertools.islice(iterable, start, None) to drop the first 'start' items.
</p>
</div>
</div>


<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">4.9. Iterating Over All Possible Combinations or Permutations</h3>
<div class="outline-text-3" id="text-2-16">
<p>
An important aspect  of itertools module: for complex iteration tasks, it is very likely there is an exist solution.
</p>
</div>

<div id="outline-container-sec-2-16-1" class="outline-4">
<h4 id="sec-2-16-1">create permutations from a iterable collection of items, by itertools.permutations(iterable[, len])</h4>
<div class="outline-text-4" id="text-2-16-1">
<p>
The return value is an iterator
</p>
<div class="org-src-container">

<pre class="src src-python">from itertools import permutations
a = ['a', 'b', 'c']
for b in permutations(a, 2):
    print(b)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-16-2" class="outline-4">
<h4 id="sec-2-16-2">create combinations from a iterable collection of items, by itertools.combinations(iterable, len)</h4>
<div class="outline-text-4" id="text-2-16-2">
<p>
The order of items does not matter
</p>
<div class="org-src-container">

<pre class="src src-python">from itertools import combinations
a = ['a', 'b', 'c']
for b in combinations(a, 2):
    print(b)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-16-3" class="outline-4">
<h4 id="sec-2-16-3">create combinations from a iterable collection of items, by itertools.combinations_with_replacement(iterable, len), same item can exist more than one times.</h4>
<div class="outline-text-4" id="text-2-16-3">
<p>
The order of items does not matter
</p>
<div class="org-src-container">

<pre class="src src-python">from itertools import combinations_with_replacement
a = ['a', 'b', 'c']
for b in combinations_with_replacement(a, 4):
    print(b)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-17" class="outline-3">
<h3 id="sec-2-17">4.10. Iterating Over the Index-Value Pairs of a Sequence, by enumerate(iterable[, start_index])</h3>
<div class="outline-text-3" id="text-2-17">
<div class="org-src-container">

<pre class="src src-python">a = ['a', 'b', 'c']
for i, v in enumerate(a, 1):
    print(i, v)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-18" class="outline-3">
<h3 id="sec-2-18">4.11. Iterating Over Multiple Sequences Simultaneously, by zip(iterable1, iterable2, ...), shortest</h3>
<div class="outline-text-3" id="text-2-18">
<p>
The zip function will create an iterator that return tuples: first element from iterable1, second element from iterable2, ...
Should the size of all iterables be the same? =&gt; No, it can be different. the returned size is the same as the shortest size of all iterables.
</p>
<div class="org-src-container">

<pre class="src src-python">a =  [1,  2, 3]
b = ['a', 'b', 'c', 'd']
for v in zip(a, b):
    print(v)
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-2-19" class="outline-3">
<h3 id="sec-2-19">Iterating Over Multiple Sequences Simultaneously, by itertools.zip_longest(iterable1, iterable2, ...), longest</h3>
<div class="outline-text-3" id="text-2-19">
<p>
If you want the returned iterator take the longest size, then use zip_longest. The element value will be None if that  iterable is exzasted.
</p>

<p>
From the two functions: zip and zip_longest, there is a lesson: it better to create different function name, than add a more  parameter.
</p>
<div class="org-src-container">

<pre class="src src-python">from itertools import zip_longest
a =  [1,  2, 3]
b = ['a', 'b', 'c', 'd']
for v in zip_longest(a, b):
    print(v)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-20" class="outline-3">
<h3 id="sec-2-20">4.12. Iterating on Items in Separate Containers, by itertools.chain(iterable1, iterable2, ...), concat iterables</h3>
<div class="outline-text-3" id="text-2-20">
<div class="org-src-container">

<pre class="src src-python">from itertools import chain
a =  [1,  2, 3]
b = ['a', 'b', 'c', 'd']
for v in chain(a, b):
    print(v)
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-2-21" class="outline-3">
<h3 id="sec-2-21">4.13. Creating Data Processing Pipelines</h3>
<div class="outline-text-3" id="text-2-21">
<p>
This section is about divide  a task to many small pipelines(steps), by use of generator
Generator is a  producer, for loop is a comsumer.
</p>
</div>


<div id="outline-container-sec-2-21-1" class="outline-4">
<h4 id="sec-2-21-1">example: iterate all matched lines from all files in a directory, recursively</h4>
<div class="outline-text-4" id="text-2-21-1">
<p>
相当于把多重QIAN TAO循环给扁平化了。但执行的顺序完全相同。generator确实比较好用。
</p>
<div class="org-src-container">

<pre class="src src-python">import os
def gen_filenames(top):
    for dirpath, dirs, files in os.walk(top):
        for f in files:
            yield os.path.join(dirpath, f)

def gen_open(filenames):
    for f in filenames:
        # print('file names: %s' % f)
        fh = open(f, encoding='utf-8')
        yield fh
        fh.close()

def gen_lines(files):
    for f in files:
        yield from f

def gen_match(lines, pattern):
    for v in  lines:
        if pattern in v:
            yield v

filenames = gen_filenames('..')
files = gen_open(filenames)
lines = gen_lines(files)
matched_lines = gen_match(lines, 'slice')

for v in matched_lines:
    print(v, end='')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-21-2" class="outline-4">
<h4 id="sec-2-21-2">[not work]change two embeded for loop to two seperate one by generator</h4>
<div class="outline-text-4" id="text-2-21-2">
<div class="org-src-container">

<pre class="src src-python">a = [1, 2, 3]
b = ['a', 'b']

for i in a:
    for j in b:
        print(i, j)

def gen_a(aiter):
    for v in aiter:
        yield v

def gen_b(aiter, biter):
    for v in aiter:
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-22" class="outline-3">
<h3 id="sec-2-22">4.14. Flattening a Nested Sequence, by generator, recursively</h3>
<div class="outline-text-3" id="text-2-22">
<p>
Why this function is not included in itertools module?
</p>
<div class="org-src-container">

<pre class="src src-python">from collections import Iterable
def  flatten(items, ignored_types=(str, bytes)):
    for v in items:
        if isinstance(v, Iterable) and not isinstance(v, ignored_types):
            yield from flatten(v, ignored_types)
        else:
            yield v

a = [1, 2, [3, 4, [5, 6], 7],  8, 'abc']
for v in a:
    print(v)

print("the flattened version")
for v in flatten(a):
    print(v)
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-2-23" class="outline-3">
<h3 id="sec-2-23">yield from just like a for loop</h3>
<div class="outline-text-3" id="text-2-23">
<div class="org-src-container">

<pre class="src src-python">def gen_a():
    for v in range(3):
        yield v

def gen_b(gena):
    yield from gena

def for_b(gena):
    for v  in gena:
        yield v

# the gen_b and for_b works exactly the same, but the yield from is better
for v in gen_b(gen_a()):
    print(v)

print('the for version')
for v in for_b(gen_a()):
    print(v)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-24" class="outline-3">
<h3 id="sec-2-24">4.15. Iterating in Sorted Order Over Merged Sorted Iterables, by heapq.merge(iterable1, iterable2, ...)</h3>
<div class="outline-text-3" id="text-2-24">
<p>
the input iterables should in sorted order. then it will create an new iterable of sorted items from all input.
</p>
<div class="org-src-container">

<pre class="src src-python">a = [1, 4, 8]
b = [2, 3,  7, 9]

import heapq
for v in heapq.merge(a, b):
    print(v)
</pre>
</div>

<p>
The function will only get the needed items into memory. So it better to merge two sorted files.
</p>

<p>
Similar  to <code>sorted(itertools.chain(*iterables))</code>, but will not read all content to memory.
</p>
</div>
</div>
<div id="outline-container-sec-2-25" class="outline-3">
<h3 id="sec-2-25">4.16. Replacing Infinite conditional while Loops with an Iterator, by iter(callable, sentinel) function</h3>
<div class="outline-text-3" id="text-2-25">
<p>
invoke the callable UNTIL it returns the sentinel
</p>

<p>
Means: repeated invoke the callable, and return its return value, until the return value equal to the sentinel.
</p>
<div class="org-src-container">

<pre class="src src-python">a = [1, 2, 3, 4, 5]
idx = -1
def foo():
    global idx
    idx+=1
    return a[idx]

for v in iter(foo, 3):
    print(v)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">chapter 8: Classes and Objects</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">8.1. Changing the String Representation of Instances</h3>
<div class="outline-text-3" id="text-3-1">
<p>
It's good practice to define both __repr__() and __str__()
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">the __repr__() method of a class: the literal representation of a object</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
eval(repr(x)) = x
It it not possiable to create an object from the repr(x) results, then the repr(x) result should be enclosed in '&lt;&gt;' 
</p>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2">the __str__() method of a class: the toString method  of a object</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The method will be called  when the object is passed to print() function
If __str__() is not provided, then __repr__() will be used.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3">the format function: positional field, by {N}, N means the nth parameter</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
ValueError: cannot switch from manual field specification to automatic field numbering
If you put a numbers to a field, then you should put numbers to all field.
</p>
<div class="org-src-container">

<pre class="src src-python">a = '{0}, {1},  {1}'.format(1, 2)
print(a)
</pre>
</div>

<p>
Get an object's attribute by {N.attt_name} syntax
</p>
<div class="org-src-container">

<pre class="src src-python">import itertools
a = '{0}, {0.chain}, {0.permutations}'.format(itertools)
print(a)
</pre>
</div>

<p>
for {0!r} or {0!s}, '!r' means use __repr__(), '!s' means use __str__(). '!s' is the default value.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">8.2. Customizing String Formatting</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">the format(aobj[, format_spec]) builtin function</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The function is equal to: aobj.__format__(format_spec)
而一般的aobj.__format__(spec) 的实现是调用 str.format(...) 函数来实现。
</p>

<p>
str.format(...) method 还支持关键字参数来指定field name.(问题：当关键字参数与普通参数混合时会发生什么？)
{:spec} 中的 spec 会传给 aobj.__format__(format_spec) 作为参数。 spec 可以为任意字符串，它可以作为参数传递给aobj.__format__() method.
</p>

<p>
str.format(aobj)时， 到底是哪个method会被调用呢？
From below codes, it can be see that if <span class="underline"><span class="underline">format</span></span> method is defined, then <span class="underline"><span class="underline">format</span></span> will be called. else <span class="underline"><span class="underline">str</span></span> will be called, when the object is formated by the str.format(...) method.
For str(aobj), aobj.__str__ will always be called.
</p>
<div class="org-src-container">

<pre class="src src-python">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        print("__repr__ called")
        return 'Point({0.x}, {0.y})'.format(self)

    def __str__(self):
        print("__str__ called")
        return '({0.x}, {0.y})'.format(self)

    def __format__(self, spec):
        print("__format__ called. spec: %s." % spec)
        return '({0.x}, {0.y})'.format(self)

p = Point(2, 3)
a = '{}'.format(p)
print(a)
print(p)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">[NOT FINISHED]8.3. Making Objects Support the Context-Management Protocol, that is, the with statement</h3>
<div class="outline-text-3" id="text-3-3">
<p>
To provide with statement support, just define two methods:
</p>
<ol class="org-ol">
<li>__enter__(self)
</li>
<li>__exit__(self, exc_ty, exc_val, tb)
</li>
</ol>

<div class="org-src-container">

<pre class="src src-python">class SaveVar:
    def __init__(self, avar):
        self.avar = avar
    def __enter__(self):
        print("__enter__ called")
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">8.5. Encapsulating Names in a Class</h3>
<div class="outline-text-3" id="text-3-4">
</div><div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">one underscore _ means private variable, just convention, you can still access that  variable outside  of a class</h4>
<div class="outline-text-4" id="text-3-4-1">
<div class="org-src-container">

<pre class="src src-python">class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    def __str__(self):
        return '(name: {}, age: {})'.format(self._name, self._age)

p = Person('Jim', 23)
print(p)
print(p._name, p._age)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">two underscore __ means name mangling, when used for inheritance</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
the variable will be renamed to _C__name. Then it will not override the super class's variable.
Because it is also has one leading underscore, so the rules for one underscore also applies.
</p>

<p>
__age is renamed to _Person__age:
</p>
<div class="org-src-container">

<pre class="src src-python">class Person:
    def __init__(self, name, age):
        self._name = name
        self.__age = age
    def __str__(self):
        return '(name: {}, age: {})'.format(self._name, self.__age)

p = Person('Jim', 23)
print(p)
print(dir(p))
print(p._name, p._Person__age)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">8.6. Creating Managed Attributes, with @property decorator/annotation, add a setter, getter, deleter to a field</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Steps:
</p>
<ol class="org-ol">
<li>first create a property object by @property decorator, on a getter method. The name of the getter should be the same with the attribute field.
</li>
<li>create the setter object: by @attribute_name.setter, on a setter method. The name of the setter should be the same with the attribute field.
</li>
<li>the getter, setter function are a way to define what will be called when the attribute with the same name is get,  set. 
e.g. the attribute name is 'foo', then the 'foo' attribute will be a object that has methods: 'getter', 'setter', 'deleter'. You can choose any name to store the real value for this  attribute, but the most common value will be add a underscore, that is '_foo'.
Type of 'foo' is &lt;class 'property'&gt;

<div class="org-src-container">

<pre class="src src-python">class Person:
    def __init__(self, name, age):
        # here the name attribute is depend on the def name(self) getter function. Not the reverse.
        self.name = name
        self.age = age
    def __str__(self):
        return '(name: {}, age: {})'.format(self.name, self.age)

    @property
    def name(self):
        print("getting name")
        return self.nameL

    @name.setter
    def name(self, name):
        print("setting name")
        if not isinstance(name, str):
            raise TypeError

        self.nameL = name

p = Person('Jim', 23)
p.name = "Tom"
print(p)
print(dir(p))
print(type(Person.name), dir(Person.name))
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">create caculate attribute by @property, getter, setter, then the attribute works like a attribute,  not a method</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Seems a good application of @property.
</p>

<div class="org-src-container">

<pre class="src src-python">class Circle:
    def __init__(self, radis):
        self.radis = radis

    @property
    def area(self):
        print("getting area")
        return self.radis*self.radis*3.14

p = Circle(4)
print(p.radis)
print(p.area)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">8.7. Calling a Method on a Parent Class, by super() function</h3>
<div class="outline-text-3" id="text-3-7">
<p>
There are many format
</p>
<div class="org-src-container">

<pre class="src src-python">super() # unbound
super(type, obj) # isinstance(obj, type)
super(type, type2) # issubclass(type2, type). issubclass(object, object) is True
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8">8.9. Creating a New Kind of Class or Instance Attribute, by creating a descriptor class for the type</h3>
<div class="outline-text-3" id="text-3-8">
<p>
如果一个类定义了三个函数： <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span>, <span class="underline"><span class="underline">delete</span></span>, 则它是一个descriptor, 可能通过它来为一个instance的attribute添加一些get, set时的函数。
</p>

<p>
@property 只是descriptor的一种表象， descriptor是最底层，最灵活的实现，在库中大量使用。 TODO： 可以再研究下基于descriptor， @property的实现。
</p>

<p>
调用顺序：如果descriptor对应的class attribute 存在, 则总会优先调用这个descriptor的函数，来获取或设置attribute的值。
但当descriptor只定义了__get__方法时，则如果同名的变量在instance.__dict__中存在，则会优先从instance.__dict__中获取。
</p>

<div class="org-src-container">

<pre class="src src-python">class Integer:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        print("__get__ method called, name: %s" % self.name)
        # If instance is None, then it is the class attribute
        if instance:
            return instance.__dict__[self.name]
        else:
            return instance

    def __set__(self, instance, value):
        print("__set__ method called, name %s, value: %s" % (self.name, value))
        instance.__dict__[self.name] = value

class Point:
    # 关键的是量的值，输入参数的值只是用于内部实现的。并且Integer的实现中使用instance.__dict__保存数据也只是一种实现方式。
    # Point.x决定了atribute的名称为x
    x = Integer('z')
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return '({0.x}, {0.y})'.format(self)


p = Point(3, 2)
print("p.x")
print(p.x)
print(p.__dict__)
# setattr(p, 'x', 5)
p.__dict__['x'] = 5
print(p.x)
print(p.__dict__)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9">8.10. Using Lazily Computed Properties, an application of descriptor</h3>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10">8.11. Simplifying the Initialization of Data Structures, by define a common base class</h3>
<div class="outline-text-3" id="text-3-10">
<div class="org-src-container">

<pre class="src src-python"># python  is very flexiable
class Structure:
    _fields = []
    def __init__(self, *args):
        if len(self._fields) != len(args):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))
        for k, v in zip(self._fields, args):
            setattr(self, k, v)
    def __str__(self):
        return '({})'.format(', '.join('{}: {}'.format(f, getattr(self, f)) for f in self._fields))

class Point(Structure):
    _fields = ['x', 'y']
    # def __str__(self):
    #     return '(x: {0.x}, y: {0.y})'.format(self)

class Circle(Structure):
    _fields = ['radius']
    # def __str__(self):
    #     return '(radius: {0.radius})'.format(self)

p = Point(1, 2)
print(p)
p = Circle(3)
print(p)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-11" class="outline-3">
<h3 id="sec-3-11">class attributes can also be accessed by instance object, such as self, but only when the same instance attribute not exists</h3>
<div class="outline-text-3" id="text-3-11">
<div class="org-src-container">

<pre class="src src-python">class Foo:
    class_attr = "ABC"
    def __init__(self, a):
        self.a = a

f = Foo('BB')
print(f.class_attr, f.a)
print(f.class_attr is Foo.class_attr)

class Bar:
    class_attr = "ABC"
    def __init__(self, a):
        self.class_attr = a
        self.a = a

b = Bar('BB')
print(b.class_attr, b.a)
print(b.class_attr is Bar.class_attr)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-12" class="outline-3">
<h3 id="sec-3-12">8.12. Defining an Interface or Abstract Base Class</h3>
<div class="outline-text-3" id="text-3-12">
</div><div id="outline-container-sec-3-12-1" class="outline-4">
<h4 id="sec-3-12-1">create an abstract base class, or interface, by abc.ABCMeta, abc.abstractmethod</h4>
<div class="outline-text-4" id="text-3-12-1">
<p>
A abstract class can't be initialized.
</p>
<div class="org-src-container">

<pre class="src src-python">from abc import ABCMeta, abstractmethod
class IStream(metaclass=ABCMeta):
    @abstractmethod
    def read(self, maxbytes=-1):
        pass
    @abstractmethod
    def write(self, data):
        pass

# typical usage:
def  foo(obj):
    if isinstance(obj, IStream):
        # processing an IStream here
        pass

a = IStream()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-12-2" class="outline-4">
<h4 id="sec-3-12-2">register another class to a 'sub class ' of a abstract base class, by abc.register(cls) function</h4>
<div class="outline-text-4" id="text-3-12-2">
<p>
Then isinstance(obj, AbstractBaseClass) will be  True. This let another class which is not a subclass of a base class, but can still pass the isinstance() test, which means implementing a interface.
</p>

<div class="org-src-container">

<pre class="src src-python">import io
# Register the built-in I/O classes as supporting our interface
IStream.register(io.IOBase)
# Open a normal file and type check
f = open('foo.txt')
isinstance(f, IStream) # Returns True
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-13" class="outline-3">
<h3 id="sec-3-13">8.13. Implementing a Data Model or Type System, by descriptor</h3>
<div class="outline-text-3" id="text-3-13">
<p>
感觉根之前小节讲到的descriptor相同，只不过用了继承的方式写了很多细小的descriptor。
</p>
</div>
</div>
<div id="outline-container-sec-3-14" class="outline-3">
<h3 id="sec-3-14">what is a descriptor? and its usage</h3>
<div class="outline-text-3" id="text-3-14">
<p>
A descriptor is  a class attribute object, which has <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span>, or <span class="underline"><span class="underline">delete</span></span> method, is used to define how a instance attribute is get, set, and delete. When an  instance attribute is get, the descriptor's <span class="underline"><span class="underline">get</span></span> method will be called. The same thing applys to <span class="underline"><span class="underline">set</span></span> and <span class="underline"><span class="underline">delete</span></span>
</p>

<p>
In descriptor's <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span> methods, we must use instance.__dict__[xxx] to get a attribute. If we use getattr(instance, xxx) to get that attribute, then there will be a recursion error as below, because the getattr() function will trigger a new call of <span class="underline"><span class="underline">get</span></span> method.
RecursionError: maximum recursion depth exceeded while calling a Python object
</p>

<p>
The relationship between the descriptor object and an instance attribute:
</p>
<ol class="org-ol">
<li>if the descriptor object is assigned to a class attribute with name 'attribute_a', then it will control the instance attribute with the same name.
</li>
<li>but there is  one exception: if only the <span class="underline"><span class="underline">get</span></span> method of a descriptor is defined, then the instance attribute with the same name will be not be controled by the  descriptor, it will be get directly from the <span class="underline"><span class="underline">dict</span></span>.
</li>
</ol>

<p>
a test:
</p>
<div class="org-src-container">

<pre class="src src-python">class TraceDescriptor:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance:
            print('Getting attribute {}, value is {}'.format(self.name, instance.__dict__[self.name]))
            return instance.__dict__[self.name]
            # return getattr(instance, self.name)
        else:
            return instance


    def __set__(self, instance, value):
        print('Setting attribute {} to {}'.format(self.name, value))
        instance.__dict__[self.name] = value

class Circle:
    radius = TraceDescriptor('radius')
    def __init__(self,  radius):
        self.radius = radius

c =  Circle(4)

print(c.radius)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-15" class="outline-3">
<h3 id="sec-3-15">8.16. Defining More Than One Constructor in a Class, use a class method</h3>
<div class="outline-text-3" id="text-3-15">
<p>
GP: Always only assign values in the default  constructor(<span class="underline"><span class="underline">init</span></span>), and do other things by other constructors
</p>
<div class="org-src-container">

<pre class="src src-python">import time

class Date:
    def __init__(self, y, m,  d):
        self.year = y
        self.month = m
        self.day =  d

    @classmethod
    def today(cls):
        t = time.localtime()
        return cls(t.tm_year, t.tm_mon, t.tm_mday)

    def __str__(self):
        return '({0.year}, {0.month}, {0.day})'.format(self)

d1 = Date(2017, 1, 2)
d2 = Date.today()
print(d1, d2)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-16" class="outline-3">
<h3 id="sec-3-16">8.17. Creating an Instance Without Invoking init</h3>
<div class="outline-text-3" id="text-3-16">
</div><div id="outline-container-sec-3-16-1" class="outline-4">
<h4 id="sec-3-16-1">the object.__new__(*args, **kwargs) method: create a bare object</h4>
<div class="outline-text-4" id="text-3-16-1">
<p>
Every object has a <span class="underline"><span class="underline">new__method, which is inheritantanted from type.__new</span></span>.
</p>

<p>
The parameter should be a type object.
</p>

<p>
When you want to create an object from a json, this method can be used.
</p>

<div class="org-src-container">

<pre class="src src-python">import aspk_common as AC
class Foo(AC.Structure):
    _fields = ['x']

f = Foo(2)
g = Foo.__new__(Foo)
print(f)
print(f.__dict__)
print(g.__dict__)
print(dir(f))
print(dir(g))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-16-2" class="outline-4">
<h4 id="sec-3-16-2">Problem: how an object is constructed?</h4>
<div class="outline-text-4" id="text-3-16-2">
<p>
I guess first create a bare object by  calling the <span class="underline"><span class="underline">new</span></span> method, then call the object's <span class="underline"><span class="underline">init</span></span> method.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-17" class="outline-3">
<h3 id="sec-3-17">8.18. Extending Classes with Mixins</h3>
<div class="outline-text-3" id="text-3-17">
</div><div id="outline-container-sec-3-17-1" class="outline-4">
<h4 id="sec-3-17-1">mixin classes, used to extend function of a class, class customization, by multiple inheritance</h4>
<div class="outline-text-4" id="text-3-17-1">
<p>
SOLVED, see another comment. How below codes works? For 'super().__getitem__(key)', why dict.__getitem__ method will be called?
</p>

<p>
After figuring out MRO, then I know how a mixin class works:
Mixin class is used to customize an existing class.
It make use of  MRO of multiple inheritance. Suppose 'Base' is the class to be customized, 'Mixin' is the mixin class, 'Foo' is the result  class, then the typical syntax is:
</p>
<div class="org-src-container">

<pre class="src src-python">class Foo(Mixin, Base):
    pass
</pre>
</div>
<p>
That is, put the mixin class as the first parent class, and the Base class as the second class. Then e.g. you want change a method of Base's behavier, such as 'foo', then you can just define a method named 'foo' in Mixin, and doing some work, then call 'super().foo(...)' to call Base's foo method.
</p>

<p>
Works like a decorator pattern.
</p>

<p>
But  what's difference between this method and by directly define the 'foo' method in Foo?
=&gt; maybe the main benifet is that  by putting the codes to a Mixin class, the codes can be easily reused.
</p>


<div class="org-src-container">

<pre class="src src-python">import aspk_common as AC
class Logging:
    __slots__ = ()
    def __getitem__(self, key):
        print('Getting {}'.format(key))
        print('self: {}\nsuper: {}'.format(self, super()))
        return super().__getitem__(key)

class LoggingDict(Logging, dict):
    pass

d = LoggingDict()
d['x'] = 2
print(d['x'])
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-18" class="outline-3">
<h3 id="sec-3-18">mutiple inheritance: how method/attribue are resolved if they exists in more than one  super classes</h3>
<div class="outline-text-3" id="text-3-18">
<p>
A method/attribute is resolved in the order of all parent class given.
e.g: 
class Foo(A, B)
if a method 'aaa' is defined in  both A and B, then A.aaa will be used.
</p>
</div>
</div>

<div id="outline-container-sec-3-19" class="outline-3">
<h3 id="sec-3-19">python multiple inheritance, super and MRO(method resolution order)</h3>
<div class="outline-text-3" id="text-3-19">
<p>
Guoid's words:
<a href="http://python-history.blogspot.fi/2010/06/method-resolution-order.html">http://python-history.blogspot.fi/2010/06/method-resolution-order.html</a>
depth first, from left to right, then delete all same classes expect the last one. Then diamond problem is solved.
</p>

<p>
For below code snippets:
From the printout, super() will return the next class in MRO(method resolve order) list, given a current class. The next class can be a real parent class for current class, or if the real parent class not exists,  then the next class will be the next parent class of the  current instance. For both two conditions, they are always the same class in MRO.
</p>

<p>
For below codes: the MRO is [C, A, B].
</p>
<ul class="org-ul">
<li>So super() in class C's result is A
</li>
<li>super() in  class A is B
</li>
<li>super() in class B is object(I guess)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-python">class A:
    def foo(self):
        print("A")
        print(super())
        super().foo()
class B:
    def foo(self):
        print("B")
        print(super())

class C(A, B):
    def foo(self):
        print("C")
        print(super())
        super().foo()

o = C()
o.foo()
print("MRO of C: ", C.__class__.__mro__)
print("MRO() of C: ", C.__class__.mro(C))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-20" class="outline-3">
<h3 id="sec-3-20">8.19. Implementing Stateful Objects or State Machines</h3>
<div class="outline-text-3" id="text-3-20">
<p>
Implementing the state pattern, by creating class for each state. In a class for one state, only define the method  use to handle the current state, all other methods should raise a 'NotImplementedError'.
Will see this latter
</p>
</div>
</div>

<div id="outline-container-sec-3-21" class="outline-3">
<h3 id="sec-3-21">8.20. Calling a Method on an Object Given the Name As a String, by getattr</h3>
<div class="outline-text-3" id="text-3-21">
<p>
A method is just an attribute of an object, so first get the method by 'getattr' given string name
</p>
<div class="org-src-container">

<pre class="src src-python">class Foo:
    def foo(self):
        print("foo")

f = Foo()
getattr(f, 'foo')()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-22" class="outline-3">
<h3 id="sec-3-22">8.20. Calling a Method on an Object Given the Name As a String, by operator.methodcaller(name, *args)</h3>
<div class="outline-text-3" id="text-3-22">
<p>
The benifit of methodcaller is that it will fix all parameters of the method. So if the method will be  called given same parameters for many differenntt object, this method might be better
</p>
<div class="org-src-container">

<pre class="src src-python">class Foo:
    def foo(self, x, y):
        print("foo: {}, {}".format(x, y))

f = Foo()
import operator
operator.methodcaller('foo', 3, 4)(f)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-23" class="outline-3">
<h3 id="sec-3-23">8.21. Implementing the Visitor Pattern</h3>
<div class="outline-text-3" id="text-3-23">
<p>
感觉这里所说的vistor pattern主要是对用于处理包含不同类型对象的list. 用于通用处理。
基于类型系统的visitor pattern, 是通过在不同的基础类中的accept函数来实现 dispatch table的。相当于把dispatch table也耦合在基础类定义中了。
但最本质的目的是对于不同类型的对象，客户代码使用相同的代码进行处理。
</p>

<p>
将dispatch table 做在哪里，只影响一点点写法，对最终达到的效果没影响。
</p>


<p>
例子：
</p>
<div class="org-src-container">

<pre class="src src-python">class Visitor:
    def visit(self, node):
        methname = 'visit_' + type(node).__name__
        meth = getattr(self, methname, None)
        if meth is None:
            meth = self.generic_visit
        return meth(node)

    def generic_visit(self, node):
        raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))

class File:
    def __init__(self, name):
        self.name = name

class RegularFile(File):
    def read_content(self):
        return "This is the content for file {}".format(self.name)

class Directory(File):
    def children(self):
        '''Return all children names as a list'''
        return [RegularFile('a.txt'), RegularFile('b.exe')]

class Symbolic(File):
    def real(self):
        '''Return real file this symbolic point to'''
        return RegularFile('dd.txt')

class CatVisitor(Visitor):
    '''Implement cat command for a File object.'''
    def  visit_RegularFile(self, node):
        print('content for regular file {}'.format(node.name))
        print(node.read_content())
    def visit_Directory(self, node):
        print('content for directory {}'.format(node.name))
        for f in node.children():
            self.visit(f)
    def visit_Symbolic(self, node):
        print('content for symbolic file {}'.format(node.name))
        self.visit(node.real())

files = [RegularFile('foo.txt'), Directory('bar'), RegularFile('a.txt'), Symbolic('aa.c')]
visitor = CatVisitor()
for file in files:
    visitor.visit(file)
    print()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-24" class="outline-3">
<h3 id="sec-3-24">dispatch table in python, decided by object type</h3>
<div class="outline-text-3" id="text-3-24">
<p>
将所有处理函数写在一个类中， 提供一个根据待处理对象类型分发的函数。 这个作为dispatch 基类。然后再定义针对每种类型的visit函数就行了。
这里类有两个目的：
</p>
<ol class="org-ol">
<li>定义dispatch table
</li>
<li>对一组函数的名字空间吧。
</li>
<li>以下例子中实现的 Dispatcher class 是通用的，可以共用。
</li>
</ol>


<div class="org-src-container">

<pre class="src src-python">class Dispatcher:
    def visit(self, node):
        methname = 'visit_' + type(node).__name__
        meth = getattr(self, methname, None)
        if meth is None:
            meth = self.generic_visit
        return meth(node)

    def generic_visit(self, node):
        raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))

class FooDispatcher(Dispatcher):
    def visit_RegularFile(self, node):
        pass
    def visit_Directory(self, node):
        pass
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-25" class="outline-3">
<h3 id="sec-3-25">8.23. Managing Memory in Cyclic Data Structures, by weakref.ref(aobject)</h3>
<div class="outline-text-3" id="text-3-25">
<p>
When cyclic reference exists, the some  object will never be deleted, because its reference coutns is  large than 0.
A weakref is just a reference that don't increase the reference count. To dereference, just call it like a function. If the referenced object still exists, the object will be returne, otherwise None will be returned.
</p>

<p>
For a tree structure, the book give an example of reference the parent node by  weakref.
</p>

<p>
Note: you can't weakref to 'int', 'str', ...
</p>
<div class="org-src-container">

<pre class="src src-python">import weakref
class Node:
    pass
a = Node()
b = weakref.ref(a)
# c = a     # if this line exists, then a will not be deleted after 'del a', then the second call to b() will still return a

print(b())
del a
print(b())
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-26" class="outline-3">
<h3 id="sec-3-26">8.24. Making Classes Support Comparison Operations, by define many comparision builtin method: <span class="underline"><span class="underline">eq</span></span>, <span class="underline"><span class="underline">lt</span></span>, <span class="underline"><span class="underline">le</span></span>, <span class="underline"><span class="underline">gt</span></span>, <span class="underline"><span class="underline">ge</span></span>, <span class="underline"><span class="underline">ne</span></span></h3>
</div>
<div id="outline-container-sec-3-27" class="outline-3">
<h3 id="sec-3-27">8.25. Creating Cached Instances, by  create a factory method(a class method)</h3>
<div class="outline-text-3" id="text-3-27">
<p>
If the parameter are the same, then return an existing object.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">chapter 5: Files and I/O</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">5.1. Reading and Writing Text Data</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">open a file</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
the 't' in mode means text.
</p>
<div class="org-src-container">

<pre class="src src-python">f = open('1.txt', 'rt') #read
# f = open('1.txt', 'wt') #write
# f = open('1.txt', 'at') #append

# specify codec
f = open('1.txt', 'rt', encoding='latin-1') #read
f = open('1.txt', 'wt', encoding='latin-1') #write

#disable newline translation, by use the open(newline='') option
f = open('1.txt', 'rt', newline='') #read

# specify what to do when encountering decoding/encoding errors, by use open(errors='...') option
f = open('1.txt', 'rt', errors='replace') #replace the char that can't be decoded to a unicode char U+fffd(which is the unicode replacemenet char)
f = open('1.txt', 'rt', errors='ignore') #just ignore the char that can't be decoded
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">read whole content of a file as a string</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">

<pre class="src src-python">with open('1.txt', 'rt') as f:
    s = f.read()
    print(s)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">read/iterate each line of a file, by just treat the file object as a generator</h4>
<div class="outline-text-4" id="text-4-1-3">
<div class="org-src-container">

<pre class="src src-python">with open('1.txt', 'rt') as f:
    for line in f:
        print(line, end='')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">write str to a file, by file.write(text) method</h4>
<div class="outline-text-4" id="text-4-1-4">
<div class="org-src-container">

<pre class="src src-python">with open('2.txt', 'wt') as f:
    f.write('abced')
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">get system's default encoding</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-python">import sys
print(sys.getdefaultencoding())
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">5.2. Printing to a File, redirect stdout to a file, by use print(file=...) option</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">

<pre class="src src-python">with open('2.txt', 'wt') as f:
    print("aaaaa", file=f)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Question: how to redirect stdout to a file system widely.</h3>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">5.3. Printing with a Different Separator or Line Ending, by use print(sep=..., end=...) options</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">

<pre class="src src-python">print(1, 'abc')
print(1, 'abc', sep=', ', end='##')
print()
row = (45, 'Hello', 'List', 4)
print(row)
print(*row)
print(row, sep=', ')
print(*row, sep=', ')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">pass a sequence/list object to a function as N parameters instead of one, by using *list_name</h3>
<div class="outline-text-3" id="text-4-6">
<div class="org-src-container">

<pre class="src src-python">row = (45, 'Hello', 'List', 4)
print(row)
print(*row)
print(row, sep=', ')
print(*row, sep=', ')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">5.4. Reading and Writing Binary Data(such as image, sound files)</h3>
<div class="outline-text-3" id="text-4-7">
<p>
By saying binary data, it means that there will no encoding/decoding works during writing/reading process.
Use mode such as 'rb', 'wb', 'ab'.
</p>

<p>
当作为binary data读取时， 与作为text data相比，没有自动的decode, encode过程。
</p>

<div class="org-src-container">

<pre class="src src-python">with open('2.txt', 'wb') as f:
    # f.write('aaabbb'.encode('latin-1'))
    f.write(b'aaabbb')
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">what is text string and byte string in python</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Each element in a text string is also a text string, 
Each element in a byte string is a int
</p>
<div class="org-src-container">

<pre class="src src-python">s = 'Hello'
print(type(s), s, sep=', ')
for c in s:
    print(type(c), c, sep=', ')

s = b'Hello'
print(type(s), s, sep=', ')
for c in s:
    print(type(c), c, sep=', ')
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9">5.5. Writing to a File That Doesn't Already Exist, by set mode of open(...) function to 'x'</h3>
<div class="outline-text-3" id="text-4-9">
<p>
If the file already exists, then don't write, and will raise a FileExistsError exception
</p>
<div class="org-src-container">

<pre class="src src-python">with open('2.txt', 'xt') as f:
    f.write('aaa bbb')
</pre>
</div>

<p>
感觉这个根python的哲学有点类似，不事先做判断，而是用exception的方式。
具体的用法可能需要将它放在一个try catch里。
</p>
</div>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10">5.6. Performing I/O Operations on a String, by io.StringIO() or io.BytesIO()</h3>
<div class="outline-text-3" id="text-4-10">
<p>
a typecal application can be simulate a file when do unit testing.
</p>
</div>
</div>

<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11">5.7. Reading and Writing Compressed Datafiles, by use gzip.open(...), or bz2.open(...)</h3>
<div class="outline-text-3" id="text-4-11">
<p>
After open the file, other operations are just the same as normal file.
</p>
</div>
</div>

<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12">5.8. Iterating Over Fixed-Sized Records, by iter(callable, sentinel)</h3>
<div class="outline-text-3" id="text-4-12">
<div class="org-src-container">

<pre class="src src-python">import functools
RECORD_SIZE = 2
with open('1.txt', 'rt') as f:
    for r in iter(functools.partial(f.read, RECORD_SIZE), ''):
        print(r, end='; ')
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-4-13" class="outline-3">
<h3 id="sec-4-13">the functools.partial(func, *args, **kwargs) function: create a new callable from a given callable with some(partial) arguments fixed. Currying</h3>
<div class="outline-text-3" id="text-4-13">
<div class="org-src-container">

<pre class="src src-python">from functools import partial

def max(a, b):
    if a&gt;b: return a
    else: return b

mm = partial(max, 3)
print(mm(4))
print(mm(2))
print(mm())
</pre>
</div>

<p>
写一个能够接收很多参数的函数，然后利用partial 来生成简易的使用接口。需要注意参数的顺序。
</p>
</div>
</div>

<div id="outline-container-sec-4-14" class="outline-3">
<h3 id="sec-4-14">5.9. Reading Binary Data into a Mutable Buffer</h3>
</div>

<div id="outline-container-sec-4-15" class="outline-3">
<h3 id="sec-4-15">5.10. Memory Mapping Binary Files, map a binary file to memory(byte array), my mmap.mmap(...) method</h3>
<div class="outline-text-3" id="text-4-15">
<p>
This is a general method to map file to memory, then you can random access the content of the file, such as by using slicing
</p>

<p>
After mapped, by change the value of the array will change the file's content. This is also a way for multiple intepreter comunication.
Below is a general function that map a file to a byte array.
</p>
<div class="org-src-container">

<pre class="src src-python">import os
import mmap

def memory_map(filename, access=mmap.ACCESS_WRITE):
    size = os.path.getsize(filename)
    fd = os.open(filename, os.O_RDWR)
    return mmap.mmap(fd, size, access=access)

# below is application of the function
f = memory_map('1.txt')
print(f[2:8])
f[0:3] = b'EEF'
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div>
</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2017-07-10</span>
        <span title="last modification date" class="post-info">2017-07-14</span>
        <span title="tags" class="post-info"><a href="/tags/python/">python</a>, <a href="/tags/reading-notes/">reading notes</a></span>
        <span title="author" class="post-info">Astropeak</span>
      </div>
      <section>
        <h1>Comments</h1>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:astropeak &lt;at&gt; gmail &lt;dot&gt; com">Astropeak</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
