<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Astropeak</title>
<style>
        @font-face {
            font-family: "libretto-icons";
            src:url(assets/fonts/libretto-icons.eot);
            src:url(assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
            url(assets/fonts/libretto-icons.woff) format("woff"),
            url(assets/fonts/libretto-icons.ttf) format("truetype"),
            url(assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
            font-weight: normal;
            font-style: normal;
        }
    </style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono%7CLibre+Baskerville%7CMontserrat%7CPlayfair+Display">
<link rel="stylesheet" href="assets/css/libretto_styles.css">
<link href="assets/css/custom.css" rel="stylesheet" type="text/css">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
            <h1 class="site-title">
                <a href="https://astropeak.github.io/" title="Astropeak" rel="home">Astropeak</a>
            </h1>
        </div>
        <nav class="site-navigation" role="navigation"><div class="menu-toggle">
                <span class="mobile-site-title">Astropeak</span>
            </div>
            <ul class="menu">
<li><a href="archive.html">Archive</a></li>
                    <li><a href="categories/">Tags</a></li>
                    <li><a href="rss.xml">RSS feed</a></li>
                    <li><a href="http://github.com/astropeak">Github</a></li>
            </ul></nav></header><div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/tensorflow-key-concepts/" rel="bookmark">May 18, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/tensorflow-key-concepts/">使用 Tensorflow 建模，你需要理解的三个概念</a></h1>
                </div>
                <div class="entry-content">
                        <p>
使用Tensorflow的基本套路是，先建立一个问题的模型，然后求解模型的参数。
建立模型要涉及到占位符（Placeholder）和变量（Variable），求解模型参数涉及优化器。
因此，只要理解了这三个概念，我们便可以使用Tensorflow构建自己的模型并求解模型的参数。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">占位符（Placeholder）</h2>
<div class="outline-text-2" id="text-1">
<p>
使用 tf.placeholder 来创建一个占位符，创建时需要指定它的类型。
比如我们要建立一个数学公式 2x<sup>2</sup> + 3x + 1，此时就需要将x定义为一个占位符。这样我们才能在求解公式的值时，动态地指定x的值。
</p>

<div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>

<span class="codeH"><span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="c1"> </span></span>  <span class="numberCircle unselectable">1</span>
<span class="codeH"><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"></span></span>  <span class="numberCircle unselectable">2</span>

<span class="n">sess</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span>
<span class="codeH"><span class="n">r</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span> <span class="c1"></span></span>  <span class="numberCircle unselectable">3</span>
</pre></div>
<ul class="org-ul">
<li>
<b>1</b> ：创建一个占位符，其类型为int32
</li>
<li>
<b>2</b> ：定义数学公式。其中自变量为x，函数值为y
</li>
<li>
<b>3</b> ：求解给定自变量x为2时，函数值y的值。通过 <code>feed_dict</code> 参数指定一个占位符的值。
运行过后，r的值为15（2*2<sup>2</sup> + 3*2 + 1）
</li>
</ul>
<p>
占位符有点像编程语言中变量的概念，但关键不同为：占位符不会保存值，当指定一个值给它后，它并不会将这个值保存起来，以便下次使用。而是你每次使用它时，都必须为它指定一个新值。而变量则会将上次的值一直保存，下次使用时你不必再指定新值，它会直接使用上次保存的值。
</p>

<p>
一个数学公式中的自变量正好需要这样：它本身没有状态（即不会保存上次的值），你每次求解公式的值时，都必须指定自变量的值。所以，占位符的作用为：
</p>

<blockquote>
<p>
占位符提供了一种给模型指定自变量值的机制
</p>
</blockquote>

<p>
一个基本规则为，在使用Tensorflow建模时，将模型的自变量和因变量定义为占位符，这就对了。
</p>

<p>
如果一个模型中包含了占位符，则在求解这个模型值时，Tensorflow会强制必须指定所有占位符的值，通过 <code>feed_dict</code> 。如上面例子所示，在求解y时，必须指定x的值。
</p>

<p>
如果没有指定x的值，如下所示：
</p>
<div class="highlight"><pre>
<span></span><span class="n">r</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
<p>
则会报一个错误：
</p>
<div class="highlight"><pre>
<span></span>You must feed a value for placeholder tensor \'Placeholder\' with dtype
</pre></div>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">关于 <code>feed_dict</code> 参数</h3>
<div class="outline-text-3" id="text-1-1">
<p>
这个参数指定所有占位符的值。为一个dict。每个key指定的一个占位符的值。key值为占位符本身，如例子中的x，对应的值为占位符的值。
</p>

<p>
当模型中包含占位符时，则在求解模型值时，必须使用 <code>feed_dict</code> 来指定所有占位符的值。
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">关于 sess.run</h3>
<div class="outline-text-3" id="text-1-2">
<p>
这个函数用于求解一个结点的值。
</p>
</div>
</div>
</div>



<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">变量（Variable）</h2>
<div class="outline-text-2" id="text-2">
<p>
使用tf.Variable创建一个变量。变量跟编程语言中的变量的概念非常相似，表示一个存储空间，能够保存一个值。变量在使用必须有一个初始值，你可以改变一个变量的值。
</p>

<p>
使用Tensoflow创建机器学习模型时，变量被用于表示模型的参数。一般来说，训练机器学习模型的过程，就是寻找模型参数的过程。在训练开始前，都会给参数一个初始值，然后逐渐修改变量的值，使得模型能够逼近训练数据。
</p>

<p>
以下是使用变量的一个例子。
</p>
<div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'my_a'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>

<span class="c1"># a variable must be initilized</span>
<span class="n">init</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">global_variables_initializer</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1"># r=9</span>
</pre></div>

<p>
变量在使用必须被初始化，通过调用 tf.global<sub>variables</sub><sub>initializer</sub>()
来实现。如果没有初始化，则会报下面的错误。
</p>

<div class="highlight"><pre>
<span></span>Attempting to use uninitialized value my_a
</pre></div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">修改变量的值</h3>
<div class="outline-text-3" id="text-2-1">
<p>
通过变量的 assign
函数来修改它的值。如下所示。
</p>
<div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'my_a'</span><span class="p">)</span>
<span class="n">init</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">global_variables_initializer</span><span class="p">()</span>
<span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">assign_to_4</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># Before run the operation, a is still 3. This is a little hard to understand</span>
<span class="k">assert</span><span class="p">(</span><span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">assign_to_4</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

<p>
但在训练机器学习模型时，并不需要自己修改变量的值，优化器会自动修改。
</p>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">优化器（Optimizer）</h2>
<div class="outline-text-2" id="text-3">
<p>
当使用占位符和变量构造好模型及目标函数后，便可使用优化来求解模型的参数。使用占位符表示模型的自变量和因变量（即模型的X，Y），使用变量表示模型的参数。
</p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">总结</h2>
<div class="outline-text-2" id="text-4">
<p>
使用Tenforflow建模时，将模型的自变量和因变量定义为占位符（Placeholder），这样我们可以动态地指定自变量和因变量的值。
</p>

<p>
将模型的参数指定为变量（Variable），并给定一个初值，这样Tensorflow在求解模型参数过程中，其可以不断修改参数的值，直到模型能够和数据点吻合。
</p>

<p>
优化器是Tensorflow求解模型的工具，梯度下降是一种常用的优化器。</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/ascii-unicode-and-utf8/" rel="bookmark">May 15, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/ascii-unicode-and-utf8/">ASCII、 Unicode 和 UTF8</a></h1>
                </div>
                <div class="entry-content">
                        <ul class="org-ul">
<li>ASCII： 英文字母与数字编号的一一对应。每个英文字母对应一个编号。范围0~127
</li>

<li>Unicode： 全世界所有语言中字符与数字编号的一一对应。也即为存在的每个字符指定一个唯一的编号。范围为0~0x10FFFF。
</li>
</ul>
<p>
所以，
</p>
<blockquote>
<p>
ASCII与Unicode是类似的东西，都是为一个字符指定一个唯一的数字编号
</p>
</blockquote>
<p>
只不过Unicode的范围更大，能够表示更多的字符。
</p>

<p>
在计算机的世界里，只有数字，而不会有什么字符。一个字符在计算机看来就是一个数字。ASCII与Unicode就是将字符与数字一一对应起来的映射。比如对于字符'A'，在计算机看来，它就是一个数字65。
</p>

<p>
当字符串被写入文件时，也是将字符串中每个字符对应的数字编号保存在文件。
</p>

<p>
以上是ASCII和Unicode的相同点。那么，二者有什么区别？
</p>

<p>
一个显著的区别是，对于同一段文本，二者保存到文件后占用的字节数不同。对于ASCII，每个数字编号占用一个字节。
而对于Unicode，每个编号则需要占用3个字节。因此对于同一段文本：'abcd'，采用ASCII格式保存时，文件的大小为4个字节。
采用Unicode保存时，文件的大小则为12个字节。
</p>

<p>
由此也可看出，当待保存文本为纯英文字母时，
</p>
<blockquote>
<p>
采用Unicode的存储效率太低了
</p>
</blockquote>

<p>
UTF8便是为了解决Unicode存储效率低下而产生的。具体的规则就不讲了，先来看一下UTF8能够达到的效果。
</p>

<p>
对于相同的文本：'abcd'，Unicode需要12个字节，而UTF8只需要4个字节（和ASCII一样，达到最优）。
</p>

<p>
UTF8之所以可以用一个字节存储英文字母，是因此它使用了变长的编码方式。也即，对于英文字母，它采用一个字节保存这个字符。对于英文字母之后的字符，它采用两个字节保存这个字符。对于再之后的字符，采用三个字节保存。最多采用四个字节保存一个字符。
</p>

<p>
所以UTF8对于存储英文字母的高效率来源于对之后字符保存效率的牺牲。这里的合理性在于：如果待保存的文本中字符大多数为英文字母，则存储效率能够提高，因为大多数字符都是采用一个字节保存。
</p>

<p>
总结来说，
</p>
<blockquote>
<p>
UTF8是对Unicode在存储效率上的优化
</p>
</blockquote>


<p>
以上便是三者的关系。
</p>

<p>
ASCII和Unicode都是为一个字符指定一个唯一的数字编号，Unicode能够表达更多的字符，相当于是ASCII的扩展。Unicode存在存储效率低下的问题，UTF8是在这个方面对Unicode的优化。
</p>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-threading-makes-tasks-parallel/" rel="bookmark">May 13, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-threading-makes-tasks-parallel/">Python：怎样用线程将任务并行化？</a></h1>
                </div>
                <div class="entry-content">
                        <p>
如果待处理任务满足：
</p>
<ol class="org-ol">
<li>可拆分，即任务可以被拆分为多个子任务，或任务是多个相同的任务的集合；
</li>
<li>任务不是CPU密集型的，如任务涉及到较多IO操作（如文件读取和网络数据处理）
</li>
</ol>
<p>
则使用多线程将任务并行运行，能够提高运行效率。
</p>

<p>
假设待处理的任务为：有很多文件目录，对于每个文件目录，搜索匹配一个给定字符串的文件的所有行（相当于是实现grep的功能）。
则此处子任务为：给定一个目录，搜索匹配一个给定字符串的文件的所有行。总的任务为处理所有目录。
</p>

<p>
将子任务表示为一个函数T，如下所示：
</p>
<div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>
  <span class="o">...</span>
</pre></div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">为每个子任务创建一个线程</h2>
<div class="outline-text-2" id="text-1">
<p>
要实现并行化，最简单的方法是为每一个子任务创建一个thread，thread处理完后退出。
</p>
<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="s2">"This is just a stub that simulate a dir operation"</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a/b/c'</span><span class="p">,</span> <span class="s1">'a/b/d'</span><span class="p">,</span> <span class="s1">'b/c'</span><span class="p">,</span> <span class="s1">'d/f'</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">'hello'</span>

<span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
  <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>
  <span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'Main thread end here'</span><span class="p">)</span>
</pre></div>

<ul class="org-ul">
<li>
<b>1</b> ：创建一个Thread对象，target参数指定这个thread待执行的函数，args参数指定target函数的输入参数
</li>
<li>
<b>2</b> ：启动这个thread。 T(dir, pattern)将被调用
</li>
<li>
<b>3</b> ：等待，直到这个thread结束。整个for循环表示主进程会等待所有子线程结束后再退出
</li>
</ul>
<p>
程序的运行结果为：
</p>
<div class="highlight"><pre>
<span></span>searching pattern hello in dir a/b/csearching pattern hello in dir d/f
searching pattern hello in dir b/c
 searching pattern hello in dir a/b/d

Main thread end here
</pre></div>
<p>
可以看出由于线程是并行运行的，部分输出会交叠。但主进程的打印总在最后。
</p>



<p>
以上例子中对于每个dir都需要创建一个thread。如果dir的数目较多，则会创建太多的thread，影响运行效率。
较好的方式是限制总线程的数目。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">限制线程数目</h2>
<div class="outline-text-2" id="text-2">
<p>
可以使用信号量（semaphore）来限制同时运行的最大线程数目。如下所示：
</p>
<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">BoundedSemaphore</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="s2">"This is just a stub that simulate a dir operation"</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>

<span class="n">threads</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a/b/c'</span><span class="p">,</span> <span class="s1">'a/b/d'</span><span class="p">,</span> <span class="s1">'b/c'</span><span class="p">,</span> <span class="s1">'d/f'</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">'hello'</span>

<span class="n">maxjobs</span> <span class="o">=</span> <span class="n">BoundedSemaphore</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>
<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="n">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
  <span class="n">maxjobs</span><span class="o">.</span><span class="n">release</span><span class="p">()</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>

<span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
  <span class="n">maxjobs</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>
  <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
  <span class="n">threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thread</span><span class="p">)</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> 

<span class="k">print</span><span class="p">(</span><span class="s1">'Main thread end here'</span><span class="p">)</span>
</pre></div>

<ul class="org-ul">
<li>
<b>1</b> ：创建一个有2个资源的信号量。一个信号量代表总的可用的资源数目，这里表示同时运行的最大线程数目为2。
</li>
<li>
<b>2</b> ：在线程结束时释放资源。运行在子线程中。
</li>
<li>
<b>3</b> ：在启动一个线程前，先获取一个资源。如果当前已经有2个线程在运行，则会阻塞，直到其中一个线程结束。
运行在主线程中。
</li>
</ul>
<p>
当限制了最大运行线程数为2后，由于只有2个线程同时运行，程序的输出更加有序，几乎总是为：
</p>
<div class="highlight"><pre>
<span></span>searching pattern hello in dir a/b/c
searching pattern hello in dir a/b/d
searching pattern hello in dir b/c
searching pattern hello in dir d/f
Main thread end here
</pre></div>


<p>
以上实现中为每个子任务创建一个线程进行处理，然后通过信号量限制同时运行的线程的数目。如果子任务很多，这种方法会创建太多的线程。更好的方法 是使用线程池。
</p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">使用线程池（Thread Pool）</h2>
<div class="outline-text-2" id="text-3">
<p>
即预先创建一定数目的线程，形成一个线程池。每个线程持续处理多个子任务（而不是处理一个就退出）。这样做的好处是：创建的线程数目会比较固定。
</p>

<p>
那么，每个线程处理哪些子任务呢？一种方法为：预先将所有子任务均分给每个线程。如下所示：
</p>
<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="s2">"This is just a stub that simulate a dir operation"</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>

<span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a/b/c'</span><span class="p">,</span> <span class="s1">'a/b/d'</span><span class="p">,</span> <span class="s1">'b/c'</span><span class="p">,</span> <span class="s1">'d/f'</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">'hello'</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>
  <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
    <span class="n">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>

<span class="n">threadsPool</span> <span class="o">=</span> <span class="p">[</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>
  <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">pattern</span><span class="p">)),</span>
  <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">dirs</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">pattern</span><span class="p">)),</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'Main thread end here'</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>
<b>1</b> ：这个函数能够处理多个dir，将作为线程的target函数
</li>
<li>
<b>2</b> ：创建一个有2个线程的线程池。并事先分配子任务给每个线程。线程1处理前两个dir，线程2处理后两个dir
</li>
<li>
<b>3</b> ：启动线程池中所有线程
</li>
</ul>
<p>
程序的输出结果为：
</p>
<div class="highlight"><pre>
<span></span>searching pattern hello in dir a/b/csearching pattern hello in dir b/c

searching pattern hello in dir d/f
 searching pattern hello in dir a/b/d
Main thread end here
</pre></div>


<p>
这种方法存在以下问题：
</p>
<ol class="org-ol">
<li>子任务分配可能不均。导致每个线程运行时间差别可能较大，则整体运行时长可能被拖长
</li>
<li>只能处理所有子任务都预先知道的情况，无法处理子任务实时出现的情况
</li>
</ol>
<p>
如果有一种方法，能够让线程知道当前所有的待处理子任务，线程一旦空闲，便可以从中获取一个任务进行处理，则以上问题都可以解决。任务队列便是解决方案。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">使用消息队列</h2>
<div class="outline-text-2" id="text-4">
<p>
可以使用Queue实现一个任务队列，用于在线程间传递子任务。主线程将所有待处理子任务放置在队列中，子线程从队列中获取子任务去处理。
如下所有（注：以下代码只运行于Python 2，因为Queue只存在于Python 2） ：
</p>

<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">import</span> <span class="nn">Queue</span>

<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="s2">"This is just a stub that simulate a dir operation"</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>

<span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a/b/c'</span><span class="p">,</span> <span class="s1">'a/b/d'</span><span class="p">,</span> <span class="s1">'b/c'</span><span class="p">,</span> <span class="s1">'d/f'</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">'hello'</span>

<span class="n">taskQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="nb">dir</span> <span class="o">=</span> <span class="n">taskQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>
      <span class="n">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
	<span class="k">continue</span>

<span class="n">threadsPool</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrapper</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span> 
  <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c1"></span>  <span class="numberCircle unselectable">4</span>

<span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
  <span class="n">taskQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">5</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'Main thread end here'</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>
<b>1</b> ：创建一个任务队列
</li>
<li>
<b>2</b> ：子线程从任务队列中获取一个任务。第一个参数为True，表示如果没有任务，会等待。第二个参数表示最长等待0.1秒
如果在0.1秒后仍然没有任务，则会抛出一个Queue.Empty的异常
</li>
<li>
<b>3</b> ：创建有2个线程的线程池。注意target函数wrapper没有任何参数
</li>
<li>
<b>4</b> ：启动所有线程
</li>
<li>
<b>5</b> ：主线程将所有子任务放置在任务队列中，以供子线程获取处理。由于子线程已经被启动，则子线程会立即获取到任务并处理
</li>
</ul>
<p>
程序的输出为：
</p>
<div class="highlight"><pre>
<span></span>searching pattern hello in dir a/b/c
searching pattern hello in dir a/b/d
searching pattern hello in dir b/c
 searching pattern hello in dir d/f
</pre></div>

<p>
从中可以看出主进程的打印结果并没有出来，程序会一直运行，而不退出。这个问题的原因是：目前的实现中，子线程为一个无限循环，
因此其永远不会终止。因此，必须有一种机制来结束子进程。
</p>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">终止子进程</h2>
<div class="outline-text-2" id="text-5">
<p>
一种简单方法为，可以在任务队列中放置一个特殊元素，作为终止符。当子线程从任务队列中获取这个终止符后，便自行退出。如下所示，使用None作为终止符。
</p>
<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">import</span> <span class="nn">Queue</span>

<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
  <span class="s2">"This is just a stub that simulate a dir operation"</span>
  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'searching pattern </span><span class="si">%s</span><span class="s1"> in dir </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">dir</span><span class="p">))</span>

<span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a/b/c'</span><span class="p">,</span> <span class="s1">'a/b/d'</span><span class="p">,</span> <span class="s1">'b/c'</span><span class="p">,</span> <span class="s1">'d/f'</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">'hello'</span>

<span class="n">taskQueue</span> <span class="o">=</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
  <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="nb">dir</span> <span class="o">=</span> <span class="n">taskQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">dir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>
	<span class="n">taskQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>
	<span class="k">break</span>

      <span class="n">T</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">Queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
	<span class="k">continue</span>

<span class="n">threadsPool</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">wrapper</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
  <span class="n">taskQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>

<span class="n">taskQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>

<span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threadsPool</span><span class="p">:</span>
  <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'Main thread end here'</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>
<b>1</b> ：如果任务为终止符（此处为None），则退出
</li>
<li>
<b>2</b> ：将这个终止符重新放回任务队列。因为只有一个终止符，如果不放回，则其它子线程获取不到，也就无法终止
</li>
<li>
<b>3</b> ：将终止符放在任务队列。注意必须放置在末尾，否则终止符后的任务无法得到处理
</li>
</ul>
<p>
修改过后，程序能够正常运行，主进程能够正常退出了。
</p>
<div class="highlight"><pre>
<span></span>searching pattern hello in dir a/b/csearching pattern hello in dir a/b/d

searching pattern hello in dir b/c
 searching pattern hello in dir d/f
Main thread end here
</pre></div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">总结</h2>
<div class="outline-text-2" id="text-6">
<p>
要并行化处理子任务，最简单的方法是为每个子任务创建一个线程去处理。这种方法的缺点是：如果子任务非常多，则需要创建的线程数目会非常多。
并且同时运行的线程数目也会较多。通过使用信号量来限制同时运行的线程数目，通过线程池来避免创建过多的线程。
</p>

<p>
与每个线程处理一个任务不同，线程池中每个线程会处理多个子任务。这带来一个问题：每个子线程如何知道要处理哪些子任务。
一种方法是预先将所有子任务均分给每个线程，而更灵活的方法则是通过任务队列，由子线程自行决定要处理哪些任务。
</p>

<p>
使用线程池时，线程主函数通常实现为一个无限循环，因此需要考虑如何终止线程。可以在任务队列中放置一个终止符来告诉线程没有更多任务，
因此其可以终止。
</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-decorator/" rel="bookmark">May 10, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-decorator/">Python 装饰器（Decorator）</a></h1>
                </div>
                <div class="entry-content">
                        <p>
装饰器的语法为 <code>@dec_name</code> ，置于函数定义之前。如：
</p>
<div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">atexit</span>

<span class="nd">@atexit.register</span>
<span class="k">def</span> <span class="nf">goodbye</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'Goodbye!'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'Script end here'</span><span class="p">)</span>
</pre></div>
<p>
<code>atexit.register</code> 是一个装饰器，它的作用是将被装饰的函数注册为在程序结束时执行。函数 <code>goodbye</code> 是被装饰的函数。
</p>

<p>
程序的运行结果是：
</p>
<div class="highlight"><pre>
<span></span>Script end here
Goodbye!
</pre></div>
<p>
可见函数 <code>goodbye</code> 在程序结束后被自动调用。
</p>

<p>
另一个常见的例子是 <code>@property</code> ，装饰类的成员函数，将其转换为一个描述符。
</p>
<div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'attr called'</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">'attr value'</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
</pre></div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">等价语法</h2>
<div class="outline-text-2" id="text-1">
<p>
语句块
</p>
<div class="highlight"><pre>
<span></span><span class="nd">@atexit.register</span>
<span class="k">def</span> <span class="nf">goodbye</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'Goodbye!'</span><span class="p">)</span>
</pre></div>
<p>
等价于
</p>
<div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">goodbye</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'Goodbye!'</span><span class="p">)</span>
<span class="n">goodbye</span> <span class="o">=</span> <span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">goodbye</span><span class="p">)</span>
</pre></div>
<p>
这两种写法在作用上完全等价。
</p>

<p>
从第二种写法，更容易看出装饰器的原理。装饰器实际上是一个函数（或callable），其输入、返回值为：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left"> </th>
<th scope="col" class="left">说明</th>
<th scope="col" class="left">示例中的对应</th>
</tr></thead>
<tbody>
<tr>
<td class="left">输入</td>
<td class="left">被装饰的函数</td>
<td class="left">goodbye</td>
</tr>
<tr>
<td class="left">返回值</td>
<td class="left">变换后的函数或任意对象</td>
<td class="left"> </td>
</tr>
</tbody>
</table>
<p>
返回值会被赋值给原来指向输入函数的变量，如示例中的 <code>goodbye</code> 。此时变量 <code>goodbye</code> 将指向装饰器的返回值，而不是原来的函数定义。返回值一般为一个函数，这个函数是在输入参数函数添加了一些额外操作的版本。
</p>

<p>
如下面这个装饰器对原始函数添加了一个操作：每次调用这个函数时，打印函数的输入参数及返回值。
</p>
<div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"></span>  <span class="numberCircle unselectable">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Enter. Args: </span><span class="si">%s</span><span class="s1">, kwargs: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span> <span class="c1"></span>  <span class="numberCircle unselectable">2</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">3</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Exit. Return value: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">rv</span><span class="p">))</span> <span class="c1"></span>  <span class="numberCircle unselectable">4</span>
    <span class="k">return</span> <span class="n">rv</span>

  <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@trace</span>
<span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'area called'</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span>

<span class="n">area</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"></span>  <span class="numberCircle unselectable">5</span>
</pre></div>
<ol class="org-ol">
<li>
<b>1</b> ：定义一个新函数，这个函数将作为装饰器的返回值，来替换原函数
</li>
<li>
<b>2</b>, <b>4</b> ： 打印输入参数、返回值。这是这个装饰器所定义的操作
</li>

<li>
<b>3</b> ：调用原函数
</li>
<li>
<b>5</b> ：此时 <code>area</code> 实际上是 <b>1</b> 处定义的 <code>wrapper</code> 函数
</li>
</ol>
<p>
程序的运行结果为：
</p>
<div class="highlight"><pre>
<span></span>Enter. Args: (2, 3), kwargs: {}
area called
Exit. Return value: 6
</pre></div>
<p>
如果不使用装饰器，则必须将以上打印输入参数及返回值的语句直接写在 <code>area</code> 函数里，如：
</p>
<div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'Enter. Args: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'area called'</span><span class="p">)</span>
  <span class="n">rv</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'Exit. Return value: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">rv</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">rv</span>

<span class="n">area</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>

<p>
程序的运行结果与使用装饰器时相同。但使用装饰器的好处为：
</p>
<ol class="org-ol">
<li>打印输入参数及返回值这个操作可被重用

<p>
如对于一个新的函数 <code>foo</code> ，装饰器 <code>trace</code> 可以直接拿来使用，而无须在函数内部重复写两条 <code>print</code> 语句。
</p>
<div class="highlight"><pre>
<span></span><span class="nd">@trace</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
  <span class="k">return</span> <span class="s1">'return value'</span>
</pre></div>

<blockquote>
<p>
一个装饰器实际上定义了一种可重复使用的操作
</p>
</blockquote>
</li>
<li>函数的功能更单纯

<p>
 <code>area</code> 函数的功能是计算面积，而调试语句与其功能无关。使用装饰器可以将与函数功能无关的语句提取出来。
因此函数可以写地更小。
</p>

<blockquote>
<p>
使用装饰器，相当于将两个小函数组合起来，组成功能更强大的函数
</p>
</blockquote>
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">修正名称</h2>
<div class="outline-text-2" id="text-2">
<p>
以上例子中有一个缺陷，函数 <code>area</code> 被 <code>trace</code> 装饰后，其名称变为 <code>wrapper</code> ，而非 <code>area</code> 。 <code>print(area)</code> 的结果为：
</p>
<div class="highlight"><pre>
<span></span>&lt;function wrapper at 0x10df45668&gt;
</pre></div>
<p>
<code>wrapper</code> 这个名称来源于 <code>trace</code> 中定义的 <code>wrapper</code> 函数。
</p>

<p>
可以通过 <code>functools.wraps</code> 来修正这个问题。
</p>
<div class="highlight"><pre>
<span class="codeH"><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span> <span class="c1"></span></span>

<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="codeH">  <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"></span></span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Enter. Args: </span><span class="si">%s</span><span class="s1">, kwargs: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'Exit. Return value: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">rv</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rv</span>

  <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@trace</span>
<span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'area called'</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span>
</pre></div>

<p>
即使用 <code>functools.wraps</code> 来装饰 <code>wrapper</code> 。此时 <code>print(area)</code> 的结果为：
</p>
<div class="highlight"><pre>
<span></span>&lt;function area at 0x10e8371b8&gt;
</pre></div>
<p>
函数的名称能够正确显示。
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">接收参数</h2>
<div class="outline-text-2" id="text-3">
<p>
以上例子中 <code>trace</code> 这个装饰器在使用时不接受参数。如果想传入参数，如传入被装饰函数的名称，可以这么做：
</p>
<div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">print</span><span class="p">(</span><span class="s1">'Enter </span><span class="si">%s</span><span class="s1">. Args: </span><span class="si">%s</span><span class="s1">, kwargs: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
      <span class="n">rv</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
      <span class="k">print</span><span class="p">(</span><span class="s1">'Exit </span><span class="si">%s</span><span class="s1">. Return value: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rv</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">rv</span>

    <span class="k">return</span> <span class="n">wrapped</span>
  <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@trace</span><span class="p">(</span><span class="s1">'area'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s1">'area called'</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span>

<span class="n">area</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>

<p>
程序的运行结果为：
</p>
<div class="highlight"><pre>
<span></span>Enter area. Args: (2, 3), kwargs: {}
area called
Exit area. Return value: 6
</pre></div>
<p>
将函数名称传入后，在日志同时打印出函数名，日志更加清晰。
</p>

<p>
<code>@trace('area')</code> 是如何工作的？
</p>

<p>
这里其实包含了两个步骤。 <code>@trace('area')</code> 等价于：
</p>
<div class="highlight"><pre>
<span></span><span class="n">dec</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="s1">'area'</span><span class="p">)</span>
<span class="nd">@dec</span>
<span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
<p>
即先触发函数调用 <code>trace('area')</code> ，得到一个返回值，这个返回值为 <code>wrapper</code> 函数。
而这个函数才是真正的装饰器，然后使用这个装饰器装饰函数。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">多重装饰器</h2>
<div class="outline-text-2" id="text-4">
<p>
装饰器可以叠加使用，如：
</p>
<div class="highlight"><pre>
<span></span><span class="nd">@dec1</span>
<span class="nd">@dec2</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span><span class="k">pass</span>
</pre></div>
<p>
等价的代码为：
</p>
<div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span><span class="k">pass</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">dec2</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">dec1</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>

<p>
即装饰器依次装饰函数，靠近函数定义的装饰器优先。相当于串联起来。
</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-descriptor/" rel="bookmark">May 9, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-descriptor/">Python描述符（Descriptor）</a></h1>
                </div>
                <div class="entry-content">
                        <p>
先看一个例子，@property。被@property修饰的成员函数，将变为一个描述符。这是最简单的创建描述符的方式。
</p>
<div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'getting attr'</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">'attr value'</span>

  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
</pre></div>

<p>
上面这个例子中， <code>attr</code> 是类 <code>Foo</code> 的一个成员函数，可通过语句 <code>foo.attr()</code> 被调用。
但当它被 <code>@property</code> 修饰后，这个成员函数将不再是一个函数，而变为一个描述符。 <code>bar</code> 是一个未被修饰的成员函数。
 <code>type(Foo.attr)</code> 与 <code>type(Foo.bar)</code> 的结果分别为：
</p>
<div class="highlight"><pre>
<span></span>&lt;type 'property'&gt;
&lt;type 'instancemethod'&gt;
</pre></div>
<p>
<code>attr</code> 的类型为 <code>property</code> （注：一个 <code>property</code> 类型的对象总是一个描述符）， <code>bar</code> 的类型为 <code>instancemethod</code> ，也即一个常规的成员函数。
</p>

<p>
此时 <code>attr</code> 将无法再被调用，当尝试调用它时，语句 <code>foo.attr()</code> 将抛出错误：
</p>
<div class="highlight"><pre>
<span></span>TypeError: 'str' object is not callable
</pre></div>
<p>
让我们来理解这个错误。
</p>

<p>
首先来看 <code>foo.attr</code> 的值：
</p>
<div class="highlight"><pre>
<span></span>attr value
</pre></div>
<p>
其类型 <code>type(foo.attr)</code> ：
</p>
<div class="highlight"><pre>
<span></span>str
</pre></div>
<p>
 <code>foo.attr</code> 的类型为 <code>str</code> ，因此便有了以上的错误，一个 <code>str</code> 对象无法被调用。其值为'attr value'，正好是原始 <code>attr</code> 函数的返回值。
因此语句 <code>foo.attr</code> 实际上触发了原始 <code>attr</code> 函数的调用，并且将函数的返回值作为其值。实际上语句 <code>print(foo.attr)</code> 的输出为：
</p>
<div class="highlight"><pre>
<span></span>getting attr
attr value
</pre></div>
<p>
进一步验证了执行语句 <code>foo.attr</code> 时，原始的 <code>attr</code> 函数被调用。
</p>

<p>
发生了什么？当执行一个访问对象属性的语句 <code>foo.attr</code> 时，结果一个函数调用被触发！这便是描述符的作用：将属性访问转变为函数调用，并由这个函数来控制这个属性的值（也即函数的返回值），以及在返回值前做定制化的操作。此时可以给描述符一个简要定义：
</p>
<blockquote>
<p>
描述符是类的一个属性，控制类实例对象访问这个属性时如何返回值及做哪些额外操作
</p>
</blockquote>

<p>
这留给程序员的空间是巨大的。。
</p>



<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">描述符协议</h2>
<div class="outline-text-2" id="text-1">
<p>
任何实现了描述符协议的类都可以作为描述符类。描述符协议为一组成员函数定义，包括：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left">函数</th>
<th scope="col" class="left">作用</th>
<th scope="col" class="left">返回值</th>
<th scope="col" class="left">是否必须</th>
</tr></thead>
<tbody>
<tr>
<td class="left"><code>__get__(self, obj, type)</code></td>
<td class="left">获取属性值</td>
<td class="left">属性的值</td>
<td class="left">是</td>
</tr>
<tr>
<td class="left"><code>__set__(self, obj, value)</code></td>
<td class="left">设置属性的值</td>
<td class="left">None</td>
<td class="left">否</td>
</tr>
<tr>
<td class="left"><code>__delete__(self, obj)</code></td>
<td class="left">删除属性</td>
<td class="left">None</td>
<td class="left">否</td>
</tr>
</tbody>
</table>
<blockquote>
<p>
如果一个类实现了以上成员函数，则它便是一个描述符类，其实例对象便是一个描述符
</p>
</blockquote>


<p>
下面是一个自定义的描述符的实现。
</p>
<div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">MyDescriptor</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'get called'</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
  <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'set called'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'delete called'</span><span class="p">)</span>
    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="n">attr</span> <span class="o">=</span> <span class="n">MyDescriptor</span><span class="p">()</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
</pre></div>
<p>
示例中  <code>MyDescriptor</code> 实现了描述符协议（也即实现了 <code>__get__, __set__, __delete__</code> 函数），因此其为一个描述符类。 <code>Foo</code> 的 <code>attr</code> 属性为 <code>MyDescriptor</code> 类的实例对象，因此它是一个描述符。
</p>

<p>
<code>print(foo.attr)</code> 的输出为：
</p>
<div class="highlight"><pre>
<span></span>get called
None
</pre></div>
<p>
可见当访问 <code>foo</code> 的 <code>attr</code> 属性时， <code>MyDescriptor</code> 的 <code>__get__</code> 函数被调用。
</p>

<p>
foo.attr = 'new value' 的输出为：
</p>
<div class="highlight"><pre>
<span></span>set called
</pre></div>
<p>
可见当为 <code>attr</code> 设置一个新值时， <code>MyDescriptor</code> 的 <code>__set__</code> 函数被调用。
</p>

<p>
再运行 <code>print(foo.attr)</code> ，输出为：
</p>
<div class="highlight"><pre>
<span></span>get called
new value
</pre></div>
<p>
可见新值已被设置。
</p>

<p>
<code>del foo.attr</code> 的输出为：
</p>
<div class="highlight"><pre>
<span></span>delete called
</pre></div>
<p>
可见当为删除属性 <code>attr</code> 时， <code>MyDescriptor</code> 的  <code>__delete__</code>  函数被调用。
</p>

<p>
再执行 <code>print(foo.attr)</code> ， <code>AttributeError</code> 被抛出：
</p>
<div class="highlight"><pre>
<span></span>get called
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "1.py", line 6, in __get__
    return self.data
AttributeError: 'MyDescriptor' object has no attribute 'data'
</pre></div>
<p>
可见属性 <code>attr</code> 已被删除。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">参数意义</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>__get__(self, obj, type)</code> 函数各个参数的意义为：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left">参数</th>
<th scope="col" class="left">意义</th>
<th scope="col" class="left">例子中的对应</th>
</tr></thead>
<tbody>
<tr>
<td class="left">self</td>
<td class="left">描述符对象本身</td>
<td class="left">Foo.attr</td>
</tr>
<tr>
<td class="left">obj</td>
<td class="left">使用描述符的对象实例</td>
<td class="left">foo</td>
</tr>
<tr>
<td class="left">type</td>
<td class="left">obj的类型</td>
<td class="left">Foo</td>
</tr>
</tbody>
</table>
<p>
<code>__set__(self, obj, value)</code> 函数的self和obj参数的意义同 <code>__get__</code> ，value的意义为：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left">参数</th>
<th scope="col" class="left">意义</th>
<th scope="col" class="left">例子中的对应</th>
</tr></thead>
<tbody><tr>
<td class="left">value</td>
<td class="left">属性的新值</td>
<td class="left">'new value'</td>
</tr></tbody>
</table>
<p>
<code>__delete__(self, obj)</code> 函数的self和obj参数的意义同 <code>__get__</code> 。
</p>

<p>
（全文完）
</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-object-attribute-lookup/" rel="bookmark">May 7, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-object-attribute-lookup/">Python对象属性查询</a></h1>
                </div>
                <div class="entry-content">
                        <p>
对于语句x.y，即获取对象x的y属性，其查询过程为：
</p>
<ol class="org-ol">
<li>查询y是否存在于 <code>x.__dict__</code> 。 存在则返回
</li>
<li>查询y是否为x的类C（及其父类）的属性。 存在则返回
</li>
<li>查询失败，抛出 AttributeError。
</li>
</ol>
<p>
以上步骤为简化过程，仅包含了对象级别属性及类级别属性的处理，同时也忽略了一些特殊情况及描述符的处理。
第一条规则处理对象级属性，第二条规则处理类级属性。这两条规则能够覆盖大多数情况。
</p>

<p>
以下是一个例子：
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="n">attr1</span> <span class="o">=</span> <span class="s1">'value1'</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr2</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attr2</span> <span class="o">=</span> <span class="n">attr2</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s1">'value2'</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">attr2</span> <span class="ow">is</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'attr2'</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">attr1</span> <span class="ow">is</span> <span class="n">Foo</span><span class="o">.</span><span class="n">attr1</span><span class="p">)</span>
</pre></div>


<p>
foo.attr2是一个对象级属性，foo.attr1是一个类级属性。
<code>assert(foo.attr2 is foo.__dict__['attr2'])</code> 为True表明foo.attr2与 <code>foo.__dict__</code> 是相同的，即其通过第一条规则查询得到。
<code>assert(foo.attr1 is Foo.attr1)</code> 为True表明foo.attr1与 Foo.attr1是相同的，所以其通过第二条规则查询得到。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">规则2的补充</h2>
<div class="outline-text-2" id="text-1">
<p>
以上第2条规则提到：查询y是否为x的类C（及其父类）的属性。即为了获取x.y，去查询C.y，其中C为x的类型。C.y具体是如何查询的呢？
</p>

<p>
C.y与x.y的查询机制相同，此时C便是一个当前的对象（事实上Python类本身是一个类型为type的对象实例）。 所以查询C.y，将以上步骤中x替换为C，则得到C.y的具体步骤：
</p>
<ol class="org-ol">
<li>查询y是否存在于 <code>C.__dict__</code> 。 存在则返回
</li>
<li>查询y是否为C的类CC（此时为type）的属性。 存在则返回
</li>
<li>查询失败，抛出 AttributeError。
</li>
</ol>
<p>
以下例子可以验证。
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="n">attr1</span> <span class="o">=</span> <span class="s1">'value1'</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr2</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attr2</span> <span class="o">=</span> <span class="n">attr2</span>

<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Foo</span><span class="p">))</span> <span class="c1"># &lt;type 'classobj'&gt;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">Foo</span><span class="o">.</span><span class="n">attr1</span> <span class="ow">is</span> <span class="n">Foo</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'attr1'</span><span class="p">])</span>    <span class="c1"># True</span>
</pre></div>


<p>
<code>type(Foo)</code> 的结果为 <code>&lt;type 'classobj'&gt;</code> 。所以Foo是类型type的一个对象实例。attr1是Foo的一个属性，保存在 <code>Foo.__dict__</code> 中（这一点，跟其它自定义对象实例一致）。
</p>

<p>
由此可见，Foo（类本身）及foo（Foo的一个对象实例）在属性查询上，并没有什么不同。他们的不同点为Foo由Python解析器自动创建（当其解析class Foo语句时），而foo一般由程序自己创建（foo = Foo('value2'))。
</p>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">描述符的处理</h2>
<div class="outline-text-2" id="text-2">
<p>
对于x.y，当属性y是一个描述符时， Python2和Python3的处理规则有所不同。对于Python2，查询规则变为：
</p>
<ol class="org-ol">
<li>查询y是否存在于 <code>x.__dict__</code> 。 存在则返回
</li>
<li>查询y是否为描述符。若是则通过描述符来处理属性获取
</li>
<li>查询y是否为x的类C（及其父类）的属性。 存在则返回
</li>
<li>查询失败，抛出 AttributeError。
</li>
</ol>
<p>
对于Python3，查询规则为：
</p>
<ol class="org-ol">
<li>查询y是否为描述符。若是则通过描述符来处理属性获取
</li>
<li>查询y是否存在于 <code>x.__dict__</code> 。 存在则返回
</li>
<li>查询y是否为x的类C（及其父类）的属性。 存在则返回
</li>
<li>查询失败，抛出 AttributeError。
</li>
</ol>
<p>
区别在于描述符属性与对象级属性（通过 <code>x.__dict__</code> 获取的属性）的优先级不同。在Python2中，对象级属性优先级更高，而在Python3中，描述符属性优先级更高。
</p>

<p>
先来看一个例子。
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="n">attr1</span> <span class="o">=</span> <span class="s1">'value1'</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr2</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'attr2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr2</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">attr2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">'value2, descriptor attr'</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s1">'value2, instance attr'</span><span class="p">)</span>
<span class="c1"># Python2的输出为: value2, instance attr</span>
<span class="c1"># Python3的输出为: value2, descriptor attr</span>
<span class="k">print</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">attr2</span><span class="p">)</span> 
</pre></div>


<p>
通过@property修饰后，函数attr2变为一个描述符。当通过foo.attr2获取attr2这个属性时，函数attr2会被调用，其返回值即为这个属性的值。
</p>

<p>
同时在 <code>__init__</code> 函数中，创建了一个同名的attr2实例级属性。需要注意此时不能使用语句 <code>self.attr2 = attr2</code> 来创建这个实例级属性，因为此时描述符已发生作用，attr2不会被保存在 <code>self.__dict__</code> 中，而是直接通过描述符函数处理。
</p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">属性y是否为描述符</h2>
<div class="outline-text-2" id="text-3">
<p>
对于语句x.y，记对象x的类型为C， C.y的类型为D。如果
</p>
<ol class="org-ol">
<li>C.y存在，即hasattr(C, 'y') 为True
</li>
<li>且 D包含一个 <code>__get__</code> 属性， 即hasattr(D, '<code>__get__</code>' )为True
</li>
</ol>
<p>
则可判定y为一个描述符。 
</p>

<p>
第1个条件表示y为x的一个类级属性，即y为C的属性。第2个条件表示这个属性的类型包含一个 <code>__get__</code> 属性。 等价的Python代码如下：
</p>
<div class="highlight"><pre><span></span><span class="n">is_descriptor</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="vm">__class__</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">):</span>
  <span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="vm">__class__</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s1">'__get__'</span><span class="p">):</span>
    <span class="n">is_descriptor</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">数据描述符及非数据描述符</h2>
<div class="outline-text-2" id="text-4">
<p>
如果一个描述符仅包含 <code>__get__</code> 属性，而没有 <code>__set__</code> 属性，则它为一个非数据描述符，也即只能获取这个属性的值，而不能修改它的值。
</p>

<p>
如果一个描述符同时包含 <code>__get__</code> 和 <code>__set__</code> 属性，则它为一个数据描述符，此时即可获取属性值，也可修改它的值。
</p>


<p>
对于Python3，之前提到的规则只适用于数据描述符。如果一个属性是一个非数据描述符，则实例级属性（ <code>x.__dict__['attr']</code> ）的优先级高于描述符的优先级，所以查询规则变为：
</p>
<ol class="org-ol">
<li>查询y是否为数据描述符。若是则通过描述符来处理属性获取
</li>
<li>查询y是否存在于 <code>x.__dict__</code> 。 存在则返回
</li>
<li>查询y是否为非数据描述符。若是则通过描述符来处理属性获取
</li>
<li>查询y是否为x的类C（及其父类）的属性。 存在则返回
</li>
<li>查询失败，抛出 AttributeError。
</li>
</ol>
<p>
通过以下例子，可以看出这样做的逻辑。假设y是一个非数据描述符，且y不存在于 <code>x.__dict__</code> 中。
</p>
<ol class="org-ol">
<li>执行语句 x.y，第1、2条规则均不满足条件，因此第3条规则发生作用，属性值通过描述符来得到。
</li>
<li>执行语句 x.y = 'new value'， 由于y为一个非数据描述符，因此无法通过这个描述符修改这个属性的值。因此y会被保存在  <code>x.__dict__</code> 中。
</li>
<li>再次执行 x.y，第2条规则满足条件，此时返回 <code>x.__dict__</code> 中保存的值
</li>
</ol>
<p>
逻辑在于，当为属性设置一个新值后（第2步），再获取这个属性的值时（第3步），这个值应该与之前设置的值相同，而不是仍然为之前通过描述符返回的值。所以在这种情况下， <code>x.__dict__</code> 的优先级需要更高。
</p>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">成员函数是非数据描述符</h2>
<div class="outline-text-2" id="text-5">
<p>
类成员函数的实现为一个非数据描述符。根据以上规则，对象的属性会覆盖对象的同名成员函数。
</p>

<p>
以下为一个例子。
</p>
<div class="highlight"><pre><span></span><span class="c1"># encoding:utf8</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">value</span>

  <span class="k">def</span> <span class="nf">attr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'attr method'</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">attr2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'attr2 method'</span><span class="p">)</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s1">'attr value'</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">attr</span> <span class="ow">is</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'attr'</span><span class="p">])</span>
<span class="n">foo</span><span class="o">.</span><span class="n">attr</span><span class="p">()</span> <span class="c1"># 错误，attr不是成员函数，无法调用</span>
<span class="n">foo</span><span class="o">.</span><span class="n">attr2</span><span class="p">()</span> <span class="c1"># 正确，输出为 attr2 method</span>
</pre></div>

<p>
对象foo包含一个属性attr，同时包含一个同名函数attr。assert 语句为True表明foo.attr为属性值，而非那个同名函数。
</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/encoding-and-decoding/" rel="bookmark">May 5, 2018</a>
                        </span>
                    </div>
                    <h1><a href="posts/encoding-and-decoding/">Encoding and Decoding</a></h1>
                </div>
                <div class="entry-content">
                        <p>
任何文件，想要保存在硬盘中时，首先要转换成某种编码。如UTF8，ASCII。编码的意思是一个字节流，因为硬盘中是以字节为单位来保存数据的。
刚开始可以简单的认为，在硬盘上保存的数据都是经过编码后的数据。那么这些数据就有一种编码格式。
</p>

<p>
每个操作系统都有默认的文件编码方式。文件被保存时，它首先被转换为这个编码格式的字节流。
</p>

<p>
一个python源文件也不例外，它在硬盘中也是以某种编码的形式保存的。这样，当python的解释器读取源文件时，必须知道这个文件的编码格式，才能读取到文件本身的内容。默认情况下，python解释器认为文件总是以ASCII的编码方式保存。也即每个字节都表示一个字符。每个字节的值总是在0到127之间。如果文件是以其他编码方式保存的，则可以通过加注释的形式，告诉解释器这个文件实际的编码方式。以下行告诉解释器文件的编码方式是UTF8。
</p>
<div class="highlight"><pre><span></span><span class="c1"># encoding:utf8</span>
</pre></div>
<p>
如果源文件中包含非ASCII字符，则必须包含上述行，否则文件无法加载，因为Python默认文件为ASCII编码的，当读取到一个非ASCII字符时，这个字符无法被读取。
</p>


<p>
文件被读取出来后，它在内存的表示是什么样的呢？首先，将文件从硬盘中读取到内存中的过程，有一个解码的过程。对于ASCII，文件在硬盘中保存的格式和内存中的格式是一样的，都是对应的数字。也即解码和编码对应的内容是相同的。
</p>

<p>
对于UTF8，解码后则为Unicode。为什么需要编码？因为编码可以节省保存空间。如果不是这个因素，则编导和解码没有必要存在。UTF8和UTF16分别是编码Unicode的不同的编码方式。Unicode由两个字节组成，所有的字符都要占两个字节。但通过UTF8编码之后，大多数常用的字符都可以用一个字节来编码，达到节省存储空间的目的。同时有些字符需要三个字节才能编码，但由于这些字符相对较少，所以整体来说，存储空间会变小。关于Unicode和UTF8关系可看<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">这里</a>
</p>


<p>
Python中的字符串是用什么格式保存的呢？
</p>

<p>
字符串保存有两种格式：一个是8bit的字符串，这个字符串是编码过后的。另外一种是Unicode字符串，这个字符串是未编码的。 <a href="https://www.pythoncentral.io/python-unicode-encode-decode-strings-python-2x/%0A">这篇文章</a>有详细的介绍。
</p>

<p>
对于一个8bit的字符串，其包含的内容就是解码后的内容。具体的编码格式有可能是就ASCII，也有可能 是UTF8。也可以认为字符串就是一个8bit的字节序列。一个容易弄混淆的概念是，尽管这个字符串是已经编码过后的内容，它仍然可以继续被编码。
</p>
<div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">'abc'</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</pre></div>

<p>
这是一种错误的用法，除了Unicode字符串，编码一个8bit字符串是错误的用法。但Python在这里做了一个workaround，即当其发现encode函数被一个8bit字符串调用时，它首先会将这个字符串decode为Unicode字符串，然后在这个Unicode字符串上调用encode函数。以上代码与以下代码等价。
</p>
<div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">'abc'</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
</pre></div>
<p>
其中s.decode()的结果是一个Unicode字符串。
</p>

<p>
编码时出现的一个错误是，unicodedecordererror ascii codec can decode …..
</p>


<p>
在解析器中输入字符串儿
</p>

<p>
具体的过程是：解析器得到这个字符串时，已经是被编码过后的。相当于是操作系统传递给解析器的。而传输的格式也是编码后的内容。而具体的编码格式是由操作系统决定的。也即解析器默认使用的编码格式。
</p>


<p>
Encoding 是将Unicode字符串转化为8bit字符串。有多种编码格式供选择，如UTF8，UTF16，UTF32。但也可以使用ASCII作为编码格式。此时编码规则为：
</p>
<ul class="org-ul">
<li>如果Unicode的值小于128，则转化为相应的ASCII字符
</li>
<li>否则，则抛出一个异常。
</li>
</ul>
<p>
以上编码过程对于latin1也是一样，只不过此时Unicode的值小于256都被认为正常的字符。
</p>


<p>
<a href="https://docs.python.org/2/howto/unicode.html">这篇文章</a>里讲解了Unicode编码为UTF8的优点。
</p>


<p>
Python Unicode的实现应该就是一个数字数组，每个元素是一个数字，这个数字表示Unicode的值。
</p>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-cookbook-readnote-5/" rel="bookmark">July 30, 2017</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-cookbook-readnote-5/">Python Cookbook 读书笔记（五）</a></h1>
                </div>
                <div class="entry-content">
                        <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">chapter 8: Classes and Objects</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">8.1. Changing the String Representation of Instances</h3>
<div class="outline-text-3" id="text-1-1">
<p>
It's good practice to define both _<sub>repr</sub>_<sub>()</sub> and _<sub>str</sub>_<sub>()</sub></p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">the _<sub>repr</sub>_<sub>()</sub> method of a class: the literal representation of a object</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
eval(repr(x)) = x
It it not possiable to create an object from the repr(x) results, then the repr(x) result should be enclosed in '&lt;&gt;' 
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">the _<sub>str</sub>_<sub>()</sub> method of a class: the toString method  of a object</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
The method will be called  when the object is passed to print() function
If _<sub>str</sub>_<sub>()</sub> is not provided, then _<sub>repr</sub>_<sub>()</sub> will be used.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">the format function: positional field, by {N}, N means the nth parameter</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
ValueError: cannot switch from manual field specification to automatic field numbering
If you put a numbers to a field, then you should put numbers to all field.
</p>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s1">'{0}, {1},  {1}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>

<p>
Get an object's attribute by {N.attt<sub>name</sub>} syntax
</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">a</span> <span class="o">=</span> <span class="s1">'{0}, {0.chain}, {0.permutations}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itertools</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>

<p>
for {0!r} or {0!s}, '!r' means use _<sub>repr</sub>_<sub>()</sub>, '!s' means use _<sub>str</sub>_<sub>()</sub>. '!s' is the default value.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">8.2. Customizing String Formatting</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">the format(aobj[, format<sub>spec]</sub>) builtin function</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
The function is equal to: aobj._<sub>format</sub>_<sub>(format<sub>spec</sub>)</sub>
而一般的aobj._<sub>format</sub>_<sub>(spec)</sub> 的实现是调用 str.format(…) 函数来实现。
</p>

<p>
str.format(…) method 还支持关键字参数来指定field name.(问题：当关键字参数与普通参数混合时会发生什么？)
{:spec} 中的 spec 会传给 aobj._<sub>format</sub>_<sub>(format<sub>spec</sub>)</sub> 作为参数。 spec 可以为任意字符串，它可以作为参数传递给aobj._<sub>format</sub>_<sub>()</sub> method.
</p>

<p>
str.format(aobj)时， 到底是哪个method会被调用呢？
From below codes, it can be see that if <span class="underline"><span class="underline">format</span></span> method is defined, then <span class="underline"><span class="underline">format</span></span> will be called. else <span class="underline"><span class="underline">str</span></span> will be called, when the object is formated by the str.format(…) method.
For str(aobj), aobj._<sub>str</sub>__ will always be called.
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__repr__ called"</span><span class="p">)</span>
	<span class="k">return</span> <span class="s1">'Point({0.x}, {0.y})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__str__ called"</span><span class="p">)</span>
	<span class="k">return</span> <span class="s1">'({0.x}, {0.y})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__format__ called. spec: </span><span class="si">%s</span><span class="s2">."</span> <span class="o">%</span> <span class="n">spec</span><span class="p">)</span>
	<span class="k">return</span> <span class="s1">'({0.x}, {0.y})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="s1">'{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">[NOT FINISHED]8.3. Making Objects Support the Context-Management Protocol, that is, the with statement</h3>
<div class="outline-text-3" id="text-1-3">
<p>
To provide with statement support, just define two methods:
</p>
<ol class="org-ol">
<li>_<sub>enter</sub>_<sub>(self)</sub>
</li>
<li>_<sub>exit</sub>_<sub>(self, exc<sub>ty</sub>, exc<sub>val</sub>, tb)</sub>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SaveVar</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">avar</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">avar</span> <span class="o">=</span> <span class="n">avar</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__enter__ called"</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">8.5. Encapsulating Names in a Class</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">one underscore _ means private variable, just convention, you can still access that  variable outside  of a class</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'(name: {}, age: {})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_age</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s1">'Jim'</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_age</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">two underscore __ means name mangling, when used for inheritance</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
the variable will be renamed to _C_<sub>name</sub>. Then it will not override the super class's variable.
Because it is also has one leading underscore, so the rules for one underscore also applies.
</p>

<p>
_<sub>age</sub> is renamed to _Person_<sub>age</sub>:
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">__age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'(name: {}, age: {})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__age</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s1">'Jim'</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_Person__age</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">8.6. Creating Managed Attributes, with @property decorator/annotation, add a setter, getter, deleter to a field</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Steps:
</p>
<ol class="org-ol">
<li>first create a property object by @property decorator, on a getter method. The name of the getter should be the same with the attribute field.
</li>
<li>create the setter object: by @attribute<sub>name</sub>.setter, on a setter method. The name of the setter should be the same with the attribute field.
</li>
<li>the getter, setter function are a way to define what will be called when the attribute with the same name is get,  set. 
e.g. the attribute name is 'foo', then the 'foo' attribute will be a object that has methods: 'getter', 'setter', 'deleter'. You can choose any name to store the real value for this  attribute, but the most common value will be add a underscore, that is '<sub>foo'</sub>.
Type of 'foo' is &lt;class 'property'&gt;

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
	<span class="c1"># here the name attribute is depend on the def name(self) getter function. Not the reverse.</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'(name: {}, age: {})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"getting name"</span><span class="p">)</span>
	<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nameL</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"setting name"</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
	    <span class="k">raise</span> <span class="ne">TypeError</span>

	<span class="bp">self</span><span class="o">.</span><span class="n">nameL</span> <span class="o">=</span> <span class="n">name</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s1">'Jim'</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"Tom"</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="nb">dir</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</pre></div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">create caculate attribute by @property, getter, setter, then the attribute works like a attribute,  not a method</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Seems a good application of @property.
</p>

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radis</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">radis</span> <span class="o">=</span> <span class="n">radis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"getting area"</span><span class="p">)</span>
	<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radis</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radis</span><span class="o">*</span><span class="mf">3.14</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">radis</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">8.7. Calling a Method on a Parent Class, by super() function</h3>
<div class="outline-text-3" id="text-1-7">
<p>
There are many format
</p>
<div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">()</span> <span class="c1"># unbound</span>
<span class="nb">super</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="c1"># isinstance(obj, type)</span>
<span class="nb">super</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span> <span class="c1"># issubclass(type2, type). issubclass(object, object) is True</span>
</pre></div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">8.9. Creating a New Kind of Class or Instance Attribute, by creating a descriptor class for the type</h3>
<div class="outline-text-3" id="text-1-8">
<p>
如果一个类定义了三个函数： <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span>, <span class="underline"><span class="underline">delete</span></span>, 则它是一个descriptor, 可能通过它来为一个instance的attribute添加一些get, set时的函数。
</p>

<p>
@property 只是descriptor的一种表象， descriptor是最底层，最灵活的实现，在库中大量使用。 TODO： 可以再研究下基于descriptor， @property的实现。
</p>

<p>
调用顺序：如果descriptor对应的class attribute 存在, 则总会优先调用这个descriptor的函数，来获取或设置attribute的值。
但当descriptor只定义了_<sub>get</sub>_<sub>方法时，则如果同名的变量在instance</sub>._<sub>dict</sub>_<sub>中存在，则会优先从instance</sub>._<sub>dict</sub>_<sub>中获取。</sub></p>

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Integer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__get__ method called, name: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
	<span class="c1"># If instance is None, then it is the class attribute</span>
	<span class="k">if</span> <span class="n">instance</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"__set__ method called, name </span><span class="si">%s</span><span class="s2">, value: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
	<span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="c1"># 关键的是量的值，输入参数的值只是用于内部实现的。并且Integer的实现中使用instance.__dict__保存数据也只是一种实现方式。</span>
    <span class="c1"># Point.x决定了atribute的名称为x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="s1">'z'</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'({0.x}, {0.y})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"p.x"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="c1"># setattr(p, 'x', 5)</span>
<span class="n">p</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">8.10. Using Lazily Computed Properties, an application of descriptor</h3>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">8.11. Simplifying the Initialization of Data Structures, by define a common base class</h3>
<div class="outline-text-3" id="text-1-10">
<div class="highlight"><pre><span></span><span class="c1"># python  is very flexiable</span>
<span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
	    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'Expected {} arguments'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">)))</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
	    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'({})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">'{}: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fields</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">]</span>
    <span class="c1"># def __str__(self):</span>
    <span class="c1">#     return '(x: {0.x}, y: {0.y})'.format(self)</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'radius'</span><span class="p">]</span>
    <span class="c1"># def __str__(self):</span>
    <span class="c1">#     return '(radius: {0.radius})'.format(self)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">class attributes can also be accessed by instance object, such as self, but only when the same instance attribute not exists</h3>
<div class="outline-text-3" id="text-1-11">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">class_attr</span> <span class="o">=</span> <span class="s2">"ABC"</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s1">'BB'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">class_attr</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">class_attr</span> <span class="ow">is</span> <span class="n">Foo</span><span class="o">.</span><span class="n">class_attr</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="n">class_attr</span> <span class="o">=</span> <span class="s2">"ABC"</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">class_attr</span> <span class="o">=</span> <span class="n">a</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">(</span><span class="s1">'BB'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">class_attr</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">class_attr</span> <span class="ow">is</span> <span class="n">Bar</span><span class="o">.</span><span class="n">class_attr</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">8.12. Defining an Interface or Abstract Base Class</h3>
<div class="outline-text-3" id="text-1-12">
</div>
<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1">create an abstract base class, or interface, by abc.ABCMeta, abc.abstractmethod</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
A abstract class can't be initialized.
</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="k">class</span> <span class="nc">IStream</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxbytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
	<span class="k">pass</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
	<span class="k">pass</span>

<span class="c1"># typical usage:</span>
<span class="k">def</span>  <span class="nf">foo</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">IStream</span><span class="p">):</span>
	<span class="c1"># processing an IStream here</span>
	<span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">IStream</span><span class="p">()</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-12-2" class="outline-4">
<h4 id="sec-1-12-2">register another class to a 'sub class ' of a abstract base class, by abc.register(cls) function</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
Then isinstance(obj, AbstractBaseClass) will be  True. This let another class which is not a subclass of a base class, but can still pass the isinstance() test, which means implementing a interface.
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="c1"># Register the built-in I/O classes as supporting our interface</span>
<span class="n">IStream</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">)</span>
<span class="c1"># Open a normal file and type check</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'foo.txt'</span><span class="p">)</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">IStream</span><span class="p">)</span> <span class="c1"># Returns True</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">8.13. Implementing a Data Model or Type System, by descriptor</h3>
<div class="outline-text-3" id="text-1-13">
<p>
感觉根之前小节讲到的descriptor相同，只不过用了继承的方式写了很多细小的descriptor。
</p>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">what is a descriptor? and its usage</h3>
<div class="outline-text-3" id="text-1-14">
<p>
A descriptor is  a class attribute object, which has <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span>, or <span class="underline"><span class="underline">delete</span></span> method, is used to define how a instance attribute is get, set, and delete. When an  instance attribute is get, the descriptor's <span class="underline"><span class="underline">get</span></span> method will be called. The same thing applys to <span class="underline"><span class="underline">set</span></span> and <span class="underline"><span class="underline">delete</span></span>
</p>

<p>
In descriptor's <span class="underline"><span class="underline">get</span></span>, <span class="underline"><span class="underline">set</span></span> methods, we must use instance._<sub>dict</sub>_<sub>[xxx]</sub> to get a attribute. If we use getattr(instance, xxx) to get that attribute, then there will be a recursion error as below, because the getattr() function will trigger a new call of <span class="underline"><span class="underline">get</span></span> method.
RecursionError: maximum recursion depth exceeded while calling a Python object
</p>

<p>
The relationship between the descriptor object and an instance attribute:
</p>
<ol class="org-ol">
<li>if the descriptor object is assigned to a class attribute with name 'attribute<sub>a'</sub>, then it will control the instance attribute with the same name.
</li>
<li>but there is  one exception: if only the <span class="underline"><span class="underline">get</span></span> method of a descriptor is defined, then the instance attribute with the same name will be not be controled by the  descriptor, it will be get directly from the <span class="underline"><span class="underline">dict</span></span>.
</li>
</ol>
<p>
a test:
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TraceDescriptor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">instance</span><span class="p">:</span>
	    <span class="k">print</span><span class="p">(</span><span class="s1">'Getting attribute {}, value is {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
	    <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
	    <span class="c1"># return getattr(instance, self.name)</span>
	<span class="k">else</span><span class="p">:</span>
	    <span class="k">return</span> <span class="n">instance</span>


    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'Setting attribute {} to {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
	<span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">TraceDescriptor</span><span class="p">(</span><span class="s1">'radius'</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">radius</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

<span class="n">c</span> <span class="o">=</span>  <span class="n">Circle</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">8.16. Defining More Than One Constructor in a Class, use a class method</h3>
<div class="outline-text-3" id="text-1-15">
<p>
GP: Always only assign values in the default  constructor(<span class="underline"><span class="underline">init</span></span>), and do other things by other constructors
</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Date</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span>  <span class="n">d</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">y</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">month</span> <span class="o">=</span> <span class="n">m</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">day</span> <span class="o">=</span>  <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">today</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>
	<span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">tm_year</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mon</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tm_mday</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s1">'({0.year}, {0.month}, {0.day})'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="n">d1</span> <span class="o">=</span> <span class="n">Date</span><span class="p">(</span><span class="mi">2017</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">d2</span> <span class="o">=</span> <span class="n">Date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16">8.17. Creating an Instance Without Invoking init</h3>
<div class="outline-text-3" id="text-1-16">
</div>
<div id="outline-container-sec-1-16-1" class="outline-4">
<h4 id="sec-1-16-1">the object._<sub>new</sub>_<sub>(*args, **kwargs)</sub> method: create a bare object</h4>
<div class="outline-text-4" id="text-1-16-1">
<p>
Every object has a <span class="underline"><span class="underline">new_<sub>method</sub>, which is inheritantanted from type._<sub>new</sub></span></span>.
</p>

<p>
The parameter should be a type object.
</p>

<p>
When you want to create an object from a json, this method can be used.
</p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">aspk_common</span> <span class="kn">as</span> <span class="nn">AC</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">AC</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'x'</span><span class="p">]</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div id="outline-container-sec-1-16-2" class="outline-4">
<h4 id="sec-1-16-2">Problem: how an object is constructed?</h4>
<div class="outline-text-4" id="text-1-16-2">
<p>
I guess first create a bare object by  calling the <span class="underline"><span class="underline">new</span></span> method, then call the object's <span class="underline"><span class="underline">init</span></span> method.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17">8.18. Extending Classes with Mixins</h3>
<div class="outline-text-3" id="text-1-17">
</div>
<div id="outline-container-sec-1-17-1" class="outline-4">
<h4 id="sec-1-17-1">mixin classes, used to extend function of a class, class customization, by multiple inheritance</h4>
<div class="outline-text-4" id="text-1-17-1">
<p>
SOLVED, see another comment. How below codes works? For 'super()._<sub>getitem</sub>_<sub>(key)</sub>', why dict._<sub>getitem</sub>__ method will be called?
</p>

<p>
After figuring out MRO, then I know how a mixin class works:
Mixin class is used to customize an existing class.
It make use of  MRO of multiple inheritance. Suppose 'Base' is the class to be customized, 'Mixin' is the mixin class, 'Foo' is the result  class, then the typical syntax is:
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">Mixin</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
<p>
That is, put the mixin class as the first parent class, and the Base class as the second class. Then e.g. you want change a method of Base's behavier, such as 'foo', then you can just define a method named 'foo' in Mixin, and doing some work, then call 'super().foo(…)' to call Base's foo method.
</p>

<p>
Works like a decorator pattern.
</p>

<p>
But  what's difference between this method and by directly define the 'foo' method in Foo?
=&gt; maybe the main benifet is that  by putting the codes to a Mixin class, the codes can be easily reused.
</p>


<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">aspk_common</span> <span class="kn">as</span> <span class="nn">AC</span>
<span class="k">class</span> <span class="nc">Logging</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'Getting {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'self: {}</span><span class="se">\n</span><span class="s1">super: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">super</span><span class="p">()))</span>
	<span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggingDict</span><span class="p">(</span><span class="n">Logging</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">LoggingDict</span><span class="p">()</span>
<span class="n">d</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'x'</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-18" class="outline-3">
<h3 id="sec-1-18">mutiple inheritance: how method/attribue are resolved if they exists in more than one  super classes</h3>
<div class="outline-text-3" id="text-1-18">
<p>
A method/attribute is resolved in the order of all parent class given.
e.g: 
class Foo(A, B)
if a method 'aaa' is defined in  both A and B, then A.aaa will be used.
</p>
</div>
</div>

<div id="outline-container-sec-1-19" class="outline-3">
<h3 id="sec-1-19">python multiple inheritance, super and MRO(method resolution order)</h3>
<div class="outline-text-3" id="text-1-19">
<p>
Guoid's words:
<a href="http://python-history.blogspot.fi/2010/06/method-resolution-order.html">http://python-history.blogspot.fi/2010/06/method-resolution-order.html</a>
depth first, from left to right, then delete all same classes expect the last one. Then diamond problem is solved.
</p>

<p>
For below code snippets:
From the printout, super() will return the next class in MRO(method resolve order) list, given a current class. The next class can be a real parent class for current class, or if the real parent class not exists,  then the next class will be the next parent class of the  current instance. For both two conditions, they are always the same class in MRO.
</p>

<p>
For below codes: the MRO is [C, A, B].
</p>
<ul class="org-ul">
<li>So super() in class C's result is A
</li>
<li>super() in  class A is B
</li>
<li>super() in class B is object(I guess)
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"A"</span><span class="p">)</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">super</span><span class="p">())</span>
	<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"B"</span><span class="p">)</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">super</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"C"</span><span class="p">)</span>
	<span class="k">print</span><span class="p">(</span><span class="nb">super</span><span class="p">())</span>
	<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>

<span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"MRO of C: "</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">"MRO() of C: "</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">mro</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-20" class="outline-3">
<h3 id="sec-1-20">8.19. Implementing Stateful Objects or State Machines</h3>
<div class="outline-text-3" id="text-1-20">
<p>
Implementing the state pattern, by creating class for each state. In a class for one state, only define the method  use to handle the current state, all other methods should raise a 'NotImplementedError'.
Will see this latter
</p>
</div>
</div>

<div id="outline-container-sec-1-21" class="outline-3">
<h3 id="sec-1-21">8.20. Calling a Method on an Object Given the Name As a String, by getattr</h3>
<div class="outline-text-3" id="text-1-21">
<p>
A method is just an attribute of an object, so first get the method by 'getattr' given string name
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">)()</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-22" class="outline-3">
<h3 id="sec-1-22">8.20. Calling a Method on an Object Given the Name As a String, by operator.methodcaller(name, *args)</h3>
<div class="outline-text-3" id="text-1-22">
<p>
The benifit of methodcaller is that it will fix all parameters of the method. So if the method will be  called given same parameters for many differenntt object, this method might be better
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s2">"foo: {}, {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-23" class="outline-3">
<h3 id="sec-1-23">8.21. Implementing the Visitor Pattern</h3>
<div class="outline-text-3" id="text-1-23">
<p>
感觉这里所说的vistor pattern主要是对用于处理包含不同类型对象的list. 用于通用处理。
基于类型系统的visitor pattern, 是通过在不同的基础类中的accept函数来实现 dispatch table的。相当于把dispatch table也耦合在基础类定义中了。
但最本质的目的是对于不同类型的对象，客户代码使用相同的代码进行处理。
</p>

<p>
将dispatch table 做在哪里，只影响一点点写法，对最终达到的效果没影响。
</p>


<p>
例子：
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Visitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="n">methname</span> <span class="o">=</span> <span class="s1">'visit_'</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
	<span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
	    <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span>
	<span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'No {} method'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'visit_'</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">File</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">RegularFile</span><span class="p">(</span><span class="n">File</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">read_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">return</span> <span class="s2">"This is the content for file {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Directory</span><span class="p">(</span><span class="n">File</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">'''Return all children names as a list'''</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">RegularFile</span><span class="p">(</span><span class="s1">'a.txt'</span><span class="p">),</span> <span class="n">RegularFile</span><span class="p">(</span><span class="s1">'b.exe'</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">Symbolic</span><span class="p">(</span><span class="n">File</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">'''Return real file this symbolic point to'''</span>
	<span class="k">return</span> <span class="n">RegularFile</span><span class="p">(</span><span class="s1">'dd.txt'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CatVisitor</span><span class="p">(</span><span class="n">Visitor</span><span class="p">):</span>
    <span class="sd">'''Implement cat command for a File object.'''</span>
    <span class="k">def</span>  <span class="nf">visit_RegularFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'content for regular file {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">read_content</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">visit_Directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'content for directory {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
	    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">visit_Symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">'content for symbolic file {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">real</span><span class="p">())</span>

<span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">RegularFile</span><span class="p">(</span><span class="s1">'foo.txt'</span><span class="p">),</span> <span class="n">Directory</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">),</span> <span class="n">RegularFile</span><span class="p">(</span><span class="s1">'a.txt'</span><span class="p">),</span> <span class="n">Symbolic</span><span class="p">(</span><span class="s1">'aa.c'</span><span class="p">)]</span>
<span class="n">visitor</span> <span class="o">=</span> <span class="n">CatVisitor</span><span class="p">()</span>
<span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
    <span class="n">visitor</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-24" class="outline-3">
<h3 id="sec-1-24">dispatch table in python, decided by object type</h3>
<div class="outline-text-3" id="text-1-24">
<p>
将所有处理函数写在一个类中， 提供一个根据待处理对象类型分发的函数。 这个作为dispatch 基类。然后再定义针对每种类型的visit函数就行了。
这里类有两个目的：
</p>
<ol class="org-ol">
<li>定义dispatch table
</li>
<li>对一组函数的名字空间吧。
</li>
<li>以下例子中实现的 Dispatcher class 是通用的，可以共用。
</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dispatcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="n">methname</span> <span class="o">=</span> <span class="s1">'visit_'</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
	<span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
	    <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span>
	<span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'No {} method'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">'visit_'</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">FooDispatcher</span><span class="p">(</span><span class="n">Dispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">visit_RegularFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">pass</span>
    <span class="k">def</span> <span class="nf">visit_Directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
	<span class="k">pass</span>
</pre></div>
</div>
</div>
<div id="outline-container-sec-1-25" class="outline-3">
<h3 id="sec-1-25">8.23. Managing Memory in Cyclic Data Structures, by weakref.ref(aobject)</h3>
<div class="outline-text-3" id="text-1-25">
<p>
When cyclic reference exists, the some  object will never be deleted, because its reference coutns is  large than 0.
A weakref is just a reference that don't increase the reference count. To dereference, just call it like a function. If the referenced object still exists, the object will be returne, otherwise None will be returned.
</p>

<p>
For a tree structure, the book give an example of reference the parent node by  weakref.
</p>

<p>
Note: you can't weakref to 'int', 'str', …
</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># c = a     # if this line exists, then a will not be deleted after 'del a', then the second call to b() will still return a</span>

<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">())</span>
<span class="k">del</span> <span class="n">a</span>
<span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">())</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-26" class="outline-3">
<h3 id="sec-1-26">8.24. Making Classes Support Comparison Operations, by define many comparision builtin method: <span class="underline"><span class="underline">eq</span></span>, <span class="underline"><span class="underline">lt</span></span>, <span class="underline"><span class="underline">le</span></span>, <span class="underline"><span class="underline">gt</span></span>, <span class="underline"><span class="underline">ge</span></span>, <span class="underline"><span class="underline">ne</span></span>
</h3>
</div>
<div id="outline-container-sec-1-27" class="outline-3">
<h3 id="sec-1-27">8.25. Creating Cached Instances, by  create a factory method(a class method)</h3>
<div class="outline-text-3" id="text-1-27">
<p>
If the parameter are the same, then return an existing object.
</p>
</div>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-object-attribute/" rel="bookmark">July 26, 2017</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-object-attribute/">Python 对象属性（一）</a></h1>
                </div>
                <div class="entry-content">
                        <p>
所有的Python 对象都有属性，可以通过 <span class="underline">obj.name</span> 这样的语法来获取属性，通过 obj.name = 'Tom' 这样的语法添加一个属性或更新属性的值（如果这个属性已存在），通过 <code>del obj.name</code> 删除一个属性。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">特殊属性和自定义属性</h2>
<div class="outline-text-2" id="text-1">
<p>
根据属性保存位置的不同，可以将属性分类为特殊属性和自定义属性。先来看一个例子。
</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">"Tom"</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="ow">is</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'__class__'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'My class'</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

<span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">'bar'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'xxx'</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">bar</span><span class="p">)</span>
</pre></div>

<p>
结果为：
</p>

<pre class="example">
{}
{'name': 'Tom'}
True
&lt;class '__main__.Foo'&gt;
&lt;class '__main__.Foo'&gt;
xxx
</pre>

<p>
从这个例子中，我们可以看出：
</p>
<ul class="org-ul">
<li>我们为一个对象新添加的属性都会被保存在 '<span class="underline"><span class="underline">dict</span></span>' 这个特殊属性中，'<span class="underline"><span class="underline">dict</span></span>'的类型是字典。如在添加了 name 这个属性后， <span class="underline"><span class="underline">dict</span></span> 的值变为 {'name': 'Tom'}，添加前为一个空字典。
</li>
<li>对于我们自己新添加的属性，可以通过两种方式来访问这个属性： f.name 和 f.__dict__['name']。这两种方式的效果完全相同，因为它们代表的是同一个变量。因此可认为 f.name 是 f.__dict__['name'] 的一种简写方式。
</li>
<li>对于任意的属性，f.xyz 的解析过程为：1. 首先检查xyz这个属性在对象中是否存在，如存在，则返回这个属性。2. 否则再检查 xyz这个属性在f.__dict__是否存在，如存在，则返回这个属性。
    如上面代码里，尽管我们通过直接在__dict__为对象添加一个名为__class__的属性，但由于这个属性对象本身就定义了，因此它还是原来的值。也即在以上第一步中即找到了这个属性。 而对于'bar' 属性，添加后再查询就是我们添加的值，在以上第2步中找到这个属性。
</li>
</ul>
<p>
因此可将一个python对象理解为一个C语言中的结构体，这个结构体的成员在对象创建后，就固定了，无法再添加新的成员。在本文中我们称这些属性为特殊属性。但实际上我们又是可以为一个对象添加新的属性的，这是怎么做到的呢？答案是每个对象都有一个名为__dict__的特殊属性，这个属性的类型为字典，所有新添加的属性都会被保存在这个字典里，在本文中我们称新添加的属性为自定义属性。但python向用户屏蔽两种属性的差别，提供了统一的语法来访问它们，也即通过 <code>obj.name</code> 。这个在大多数情况下会带来便利性，但有时会带来含混，此时我们需要弄清楚到底一个属性是一个特殊属性还是自定义属性。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">一些例子</h2>
<div class="outline-text-2" id="text-2">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Tom'</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="k">pass</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">foo</span><span class="p">)</span>
</pre></div>

<p>
结果为：
</p>

<pre class="example">
{'id': 1, 'name': 'Tom'}
&lt;bound method Foo.foo of &lt;__main__.Foo object at 0x000000B2509ECFD0&gt;&gt;
</pre>

<ul class="org-ul">
<li>可见一个类的__init__函数对self添加的属性，都将成为这个类实例对象的自定义属性，如例子中的id 和name两个属性。
</li>
<li>类中定义的函数，将成为类实例的特殊属性，如例子中的foo这个属性，它的类型是method.
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">对象属性的分类及一些例子</h2>
<div class="outline-text-2" id="text-3">
<p>
对于任何对象，其属性可分为两种(以下说的都是自己的属性，不包括父类的属性)：
</p>
<ol class="org-ol">
<li>用户自定义属性。
</li>
<li>语言定义属性
</li>
</ol>
<p>
对于一个class object，其两种属性可能包含：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left">用户自定义属性</th>
<th scope="col" class="left">语言定义属性</th>
</tr></thead>
<tbody>
<tr>
<td class="left">所有类变量</td>
<td class="left"><span class="underline"><span class="underline">mro</span></span></td>
</tr>
<tr>
<td class="left">所有类函数</td>
<td class="left"><span class="underline"><span class="underline">dict</span></span></td>
</tr>
<tr>
<td class="left">所有类描述符</td>
<td class="left"> </td>
</tr>
<tr>
<td class="left"><span class="underline"><span class="underline">doc</span></span></td>
<td class="left"> </td>
</tr>
<tr>
<td class="left"><span class="underline"><span class="underline">module</span></span></td>
<td class="left"> </td>
</tr>
</tbody>
</table>
<p>
那么如何为一个class object添加自定义属性？
在定义一个类时，一个def 语句将添加一个类函数到自定义属性; 一个赋值语句将添加一个类变量到自定义属性。
</p>

<p>
注：其实对于class object, 它也是type class object 的instance
</p>

<p>
对于一个instance object, 其两种属性可能包含：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
</colgroup>
<thead><tr>
<th scope="col" class="left">用户自定义属性</th>
<th scope="col" class="left">语言定义属性</th>
</tr></thead>
<tbody>
<tr>
<td class="left">所有属性</td>
<td class="left"><span class="underline"><span class="underline">class</span></span></td>
</tr>
<tr>
<td class="left"> </td>
<td class="left"><span class="underline"><span class="underline">dict</span></span></td>
</tr>
</tbody>
</table>
<p>
问题： str.__class__ 是一个语言定义属性还是继承自 其父类 object 的__class__ 用户自定义属性（也即object.__dict__['<span class="underline"><span class="underline">class</span></span>'], 这个是一个'attribute'）？
应该是一个语言定义属性，应该来自于 object.__dict__['<span class="underline"><span class="underline">class</span></span>']， 也可能是
</p>

<p>
问题二： str.__mro__ 的结果是： (str, object). 但我不知道这个成员来自于何处。 str.__dict__和object.__dict__里都没有。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">__dict__属性的作用</h2>
<div class="outline-text-2" id="text-4">
<p>
__dict__属性是一个语言定义属性，它用来保存所有的用户自定义属性。
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">属性的查找机制</h2>
<div class="outline-text-2" id="text-5">
<p>
x.name 等价于 getattr(x, 'name')，
</p>
</div>
</div>
                </div>
            </article>
</div>
        <div class="site-content">
            <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
                    <div class="entry-meta">
                        <span class="posted-on">
                            Posted on <a href="posts/python-cookbook-readnote-4/" rel="bookmark">July 25, 2017</a>
                        </span>
                    </div>
                    <h1><a href="posts/python-cookbook-readnote-4/">Python Cookbook 读书笔记（四）</a></h1>
                </div>
                <div class="entry-content">
                        <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">chapter 5: Files and I/O</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">5.1. Reading and Writing Text Data</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">open a file</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
the 't' in mode means text.
</p>
<div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">)</span> <span class="c1">#read</span>
<span class="c1"># f = open('1.txt', 'wt') #write</span>
<span class="c1"># f = open('1.txt', 'at') #append</span>

<span class="c1"># specify codec</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">'latin-1'</span><span class="p">)</span> <span class="c1">#read</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'wt'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">'latin-1'</span><span class="p">)</span> <span class="c1">#write</span>

<span class="c1">#disable newline translation, by use the open(newline='') option</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span> <span class="c1">#read</span>

<span class="c1"># specify what to do when encountering decoding/encoding errors, by use open(errors='...') option</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">'replace'</span><span class="p">)</span> <span class="c1">#replace the char that can't be decoded to a unicode char U+fffd(which is the unicode replacemenet char)</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">)</span> <span class="c1">#just ignore the char that can't be decoded</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">read whole content of a file as a string</h4>
<div class="outline-text-4" id="text-1-1-2">
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">read/iterate each line of a file, by just treat the file object as a generator</h4>
<div class="outline-text-4" id="text-1-1-3">
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
	<span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">write str to a file, by file.write(text) method</h4>
<div class="outline-text-4" id="text-1-1-4">
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'2.txt'</span><span class="p">,</span> <span class="s1">'wt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'abced'</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">get system's default encoding</h3>
<div class="outline-text-3" id="text-1-2">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getdefaultencoding</span><span class="p">())</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">5.2. Printing to a File, redirect stdout to a file, by use print(file=…) option</h3>
<div class="outline-text-3" id="text-1-3">
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'2.txt'</span><span class="p">,</span> <span class="s1">'wt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"aaaaa"</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Question: how to redirect stdout to a file system widely.</h3>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">5.3. Printing with a Different Separator or Line Ending, by use print(sep=…, end=…) options</h3>
<div class="outline-text-3" id="text-1-5">
<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'abc'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'abc'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">'##'</span><span class="p">)</span>
<span class="k">print</span><span class="p">()</span>
<span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s1">'Hello'</span><span class="p">,</span> <span class="s1">'List'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">pass a sequence/list object to a function as N parameters instead of one, by using *list<sub>name</sub>
</h3>
<div class="outline-text-3" id="text-1-6">
<div class="highlight"><pre><span></span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="s1">'Hello'</span><span class="p">,</span> <span class="s1">'List'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">5.4. Reading and Writing Binary Data(such as image, sound files)</h3>
<div class="outline-text-3" id="text-1-7">
<p>
By saying binary data, it means that there will no encoding/decoding works during writing/reading process.
Use mode such as 'rb', 'wb', 'ab'.
</p>

<p>
当作为binary data读取时， 与作为text data相比，没有自动的decode, encode过程。
</p>

<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'2.txt'</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># f.write('aaabbb'.encode('latin-1'))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">'aaabbb'</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">what is text string and byte string in python</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Each element in a text string is also a text string, 
Each element in a byte string is a int
</p>
<div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s1">'Hello'</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'Hello'</span>
<span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">', '</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">5.5. Writing to a File That Doesn't Already Exist, by set mode of open(…) function to 'x'</h3>
<div class="outline-text-3" id="text-1-9">
<p>
If the file already exists, then don't write, and will raise a FileExistsError exception
</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'2.txt'</span><span class="p">,</span> <span class="s1">'xt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'aaa bbb'</span><span class="p">)</span>
</pre></div>

<p>
感觉这个根python的哲学有点类似，不事先做判断，而是用exception的方式。
具体的用法可能需要将它放在一个try catch里。
</p>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">5.6. Performing I/O Operations on a String, by io.StringIO() or io.BytesIO()</h3>
<div class="outline-text-3" id="text-1-10">
<p>
a typecal application can be simulate a file when do unit testing.
</p>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">5.7. Reading and Writing Compressed Datafiles, by use gzip.open(…), or bz2.open(…)</h3>
<div class="outline-text-3" id="text-1-11">
<p>
After open the file, other operations are just the same as normal file.
</p>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">5.8. Iterating Over Fixed-Sized Records, by iter(callable, sentinel)</h3>
<div class="outline-text-3" id="text-1-12">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="n">RECORD_SIZE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">,</span> <span class="s1">'rt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="n">RECORD_SIZE</span><span class="p">),</span> <span class="s1">''</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">'; '</span><span class="p">)</span>
</pre></div>
</div>
</div>



<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">the functools.partial(func, *args, **kwargs) function: create a new callable from a given callable with some(partial) arguments fixed. Currying</h3>
<div class="outline-text-3" id="text-1-13">
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">b</span>

<span class="n">mm</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">mm</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">mm</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">mm</span><span class="p">())</span>
</pre></div>

<p>
写一个能够接收很多参数的函数，然后利用partial 来生成简易的使用接口。需要注意参数的顺序。
</p>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">5.9. Reading Binary Data into a Mutable Buffer</h3>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">5.10. Memory Mapping Binary Files, map a binary file to memory(byte array), my mmap.mmap(…) method</h3>
<div class="outline-text-3" id="text-1-15">
<p>
This is a general method to map file to memory, then you can random access the content of the file, such as by using slicing
</p>

<p>
After mapped, by change the value of the array will change the file's content. This is also a way for multiple intepreter comunication.
Below is a general function that map a file to a byte array.
</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">mmap</span>

<span class="k">def</span> <span class="nf">memory_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">mmap</span><span class="o">.</span><span class="n">ACCESS_WRITE</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmap</span><span class="o">.</span><span class="n">mmap</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="n">access</span><span class="p">)</span>

<span class="c1"># below is application of the function</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">memory_map</span><span class="p">(</span><span class="s1">'1.txt'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'EEF'</span>
</pre></div>
</div>
</div>
</div>
                </div>
            </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
                <a href="index-2.html" rel="prev">
                    <span class="meta-nav">Older Entries</span>                </a>
            </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
            <aside class="widget"><h2 class="widget-title">Astropeak</h2>
                <div class="widget-text">Astropeak's blogs.</div>
            </aside>
</div>
    </section><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
            <p>Contents © 2018         <a href="mailto:astropeak@gmail.com">Astropeak</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
        </div>
        <div class="social">
            <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>
